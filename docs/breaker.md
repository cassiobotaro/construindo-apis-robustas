# üîå Circuit breaker

![](imgs/disjuntor.jpg)

# üî• O problema

Sistemas falham! E devemos estar preparados pra quando isto ocorrer.

Se tudo foi implementado at√© o momento (incluindo os desafios), n√≥s temos integra√ß√µes com dois sistemas distintos. E se um deles falhar? ou ambos? Vamos parar todo o nosso sistema por conta disto?

E como saber se n√£o √© apenas uma instabilidade? E se √© uma falha de rede? 

Voc√™ talvez j√° tenha ouvido falar em [retentativas](https://docs.microsoft.com/pt-br/azure/architecture/patterns/retry) em cen√°rios de integra√ß√£o, mas essas retentativas podem degradar ainda mais o sistema ao qual estamos integrando.

üôÄ E agora? O que podemos fazer?

E se pux√°ssemos o plug que liga nosso sistema ao sistema externo temporariamente?

O que vamos falar aqui se aplica a integra√ß√µes com sistemas de terceiros ou sistemas distribu√≠dos internos.

## üîå Circuit breaker

A tradu√ß√£o seria, "disjuntor", e seu papel na eletr√¥nica √© abrir o circuito que apresenta falha evitando uma sobrecarga de seus componentes. Esse termo tamb√©m √© utilizado na bolsa de valores para quando h√° uma grande instabilidade (uma forte queda por exemplo), assim a bolsa de valores interrompe as negocia√ß√µes temporariamente, evitando maiores perdas nesses momentos.

Notaram uma semelhan√ßa na utiliza√ß√£o do conceito? Temos uma falha e uma "abertura" do circuito para evitar maiores danos.

Assim funciona o _circuit breaker_ na computa√ß√£o. Quando falamos em abrir um circuito, estamos falando na verdade em interromper a comunica√ß√£o entre sistemas (temporariamente).

Nygard em seu livro [Release It](https://www.amazon.com.br/Release-It-Nygard-Dahl/dp/8573500862) explica bem o circuit breaker.

!!! quote
    [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system.

Nosso sistema tem os seguintes estados:

Estado fechado: √© o estado onde tudo est√° funcionando normalmente e as requisi√ß√µes ser√£o feitas normalmente. Quando alguma condi√ß√£o de falha √© detectada, o circuito √© aberto.

Estado aberto: √© o estado onde o circuito est√° aberto e as requisi√ß√µes n√£o ser√£o executadas. Um erro ser√° retornado ou uma informa√ß√£o presente em cache.

Estado semi aberto: √© o estado posterior ao estado aberto. Um teste √© feito para verificar a condi√ß√£o atual do circuito, se uma falha ocorrer, o estado ser√° alternado para aberto novamente, mas se for bem-sucedido, ele volta para o estado fechado. 


## üßë‚Äçüè´ Demonstra√ß√£o e Solu√ß√£o

Vamos fazer uma simula√ß√£o utilizando c√≥digo para visualisar melhor este cen√°rio.

Crie um arquivo de exemplo como visto abaixo e execute-o para ver na pr√°tica o que estamos falando.

Para executa-lo utilize: `python exemplo_circuito_breaker.py`

```py title="exemplo_circuito_breaker.py"
import asyncio

import httpx


async def recupera_produto(codigo):
    print(f"Recuperando produto de c√≥digo {codigo}")
    try:
        async with httpx.AsyncClient() as cliente:
            resposta = await cliente.get(f"http://localhost:8000/catalogs/{codigo}")
            resposta.raise_for_status()
            print(resposta.json())
    except httpx.HTTPStatusError as e:
        print(f"Erro ao recuperar produto de c√≥digo {codigo}: {e}")


async def main():
    codigo_produtos = ["155568600", "jj2a97g940", "cb9a1801k9", "224722100", "702915400"] * 20
    await asyncio.gather(
        *(recupera_produto(codigo) for codigo in codigo_produtos),
    )


asyncio.run(main())
```

!!! warning
    Como as APIs abertas do Magalu se encontram em alpha, uma autoriza√ß√£o pr√©via √© necess√°ria. Por isso, voc√™ pode utilizar uma vers√£o simulada da mesma.

    As instru√ß√µes de instala√ß√£o e execu√ß√£o se encontram no readme do [projeto](./apis-simuladas).

Este c√≥digo simula o que chamamos de estado de circuito fechado, as chamadas a api externa est√£o sendo feitas e respondendo normalmente.

Agora vamos introduzir um pouco de caos e ver o que acontece.

Se estiver acompanhando o tutorial posteriormente, modifique a vari√°vel de ambiente `FAIL_RATE` para 70 (valor expresso em porcentagem) e execute o c√≥digo da api simulada novamente.

Rode novamente nosso c√≥digo (talvez seja necess√°rio rodar algumas vezes) e veja o que acontece: `python exemplo_circuito_breaker.py`.

Repare que agora um n√∫mero menor de pedidos s√£o retornados com sucesso e falhas ocorrem de forma intermitente.

Por algum motivo qualquer, algumas chamadas a api externa respondem com erro. Isto pode significar um problema de rede, uma falha na api externa, sobrecarga de requisi√ß√µes na api externa, etc.

Precisamos dar um tempo para ver se o sistema que estamos interagindo se recupera.

Vamos introduzir ent√£o um `circuit breaker` para modificarmos nosso sistema para um estado aberto.

O luizalabs desenvolveu e mant√©m como projeto open source o [lasier](https://github.com/luizalabs/lasier), uma implementa√ß√£o de circuit breaker com suporte a processos s√≠ncronos e ass√≠ncronos.

Para n√£o precisarmos adicionar maior complexidade ao exemplo utilizaremos um cache em mem√≥ria para guardar as informa√ß√µes do nosso circuito (como n√∫mero de requisi√ß√µes que falharam). Esse cache em mem√≥ria ser√° feito utilizando a biblioteca [aiocache](https://github.com/aio-libs/aiocache).

Primeiro passo √© instalar as duas bibliotecas que ser√£o necess√°rias:

Lasier:

```
poetry add lasier
```

Aiocache:

```
poetry add aiocache
```

Pr√≥ximo passo √© definir uma regra de quando vamos abrir o circuito:

```python
# ...
from lasier.circuit_breaker.rules import PercentageFailuresRule

rule = PercentageFailuresRule(
    # Numero escolhido para facilitar 
    # a visualiza√ß√£o da solu√ß√£o do problema
    max_failures_percentage=30,
    failure_cache_key='my_cb',
    min_accepted_requests=10,
    request_cache_key='my_cb_request'
)
# ...
```

Essa configura√ß√£o pode ser feita baseada tamb√©m em n√∫mero de [requisi√ß√µes com falha](https://github.com/luizalabs/lasier#maxfailuresrule).

Al√©m da regra de abertura do circuito, vamos definir um cache para armazenar as informa√ß√µes do circuito e das requisi√ß√µes que falharam.

```py
# ...
from aiocache import Cache
from lasier.adapters.caches import AiocacheAdapter
# ...
cache = AiocacheAdapter(Cache(Cache.MEMORY))
```

E agora vamos definir o circuito:

```python
import asyncio

import httpx
from aiocache import Cache
from lasier.adapters.caches import AiocacheAdapter
from lasier.circuit_breaker.asyncio import CircuitBreaker
from lasier.circuit_breaker.rules import PercentageFailuresRule

rule = PercentageFailuresRule(
    # Numero escolhido para facilitar
    # a visualiza√ß√£o da solu√ß√£o do problema
    max_failures_percentage=50,
    failure_cache_key="my_cb",
    min_accepted_requests=10,
    request_cache_key="my_cb_request",
)

cache = AiocacheAdapter(Cache(Cache.MEMORY))


class OpenCircuitError(Exception):
    pass


def with_circuit_breaker(func):
    async def wrapper(*args, **kwargs):
        try:

            async with CircuitBreaker(
                rule,
                cache,
                failure_exception=OpenCircuitError,
                catch_exceptions=(httpx.HTTPStatusError,),
            ):
                return await func(*args, **kwargs)

        except OpenCircuitError:
            # aqui poderia vir um tratamento para
            # quando o circuito est√° aberto como:
            # - enviar um email para o time
            # - reagendar a execu√ß√£o da fun√ß√£o
            # - recuperar o valor armazenado em cache
            print("O circuito est√° aberto, alguma a√ß√£o pode ser tomada.")

    return wrapper


@with_circuit_breaker
async def recupera_produto(codigo):
    print(f"Recuperando produto de c√≥digo {codigo}")
    async with httpx.AsyncClient() as cliente:
        resposta = await cliente.get(f"http://localhost:8000/catalogs/{codigo}")
        resposta.raise_for_status()
        print(resposta.json())


async def main():
    codigo_produtos = ["155568600", "jj2a97g940", "cb9a1801k9", "224722100", "702915400"] * 20
    await asyncio.gather(
        *(recupera_produto(codigo) for codigo in codigo_produtos),
    )


asyncio.run(main())
```

Eu decidi criar um decorador para introduzir o circuit breaker. Ao perceber que o circuito est√° aberto, ele n√£o executa a fun√ß√£o, mas sim retorna um erro alertando sobre a abertura do circuito e uma a√ß√£o pode ser tomada.

> üíÅ Voc√™ deve estar se perguntando: "E como funciona o estado semi aberto?". Infelizmente isto ainda n√£o foi implementado e por padr√£o o circuito ser√° fechado em 60 segundos, ou outro valor configurado.
> Mas como √© um projeto de c√≥digo aberto, convido voc√™s a contribuirem e implementarem esta funcionalidade.

## ‚å®Ô∏è Modificando nossa API

Que tal adicionar _circuit breaker_ em nosso sistema?

üó£Ô∏è Quais seriam os pontos onde dever√≠amos adicionar o circuit breaker? Em caso de falha o que faremos, retornaremos o valor em cache? Vamos adicionar algum recurso para isto como o `Redis`?

Ser√° que esta t√©cnica √© mesmo necess√°ria no nosso projeto?

Reflita sobre estes questionamentos.

Estas discuss√µes s√£o importantes e todas elas t√™m um "trade off", ou seja, podem ter algum custo.

## üíæ Salvando a vers√£o atual do c√≥digo

Caso decida modificar o seu c√≥digo para utilizar circuit breaker, como estamos adicionando novas bibliotecas ao nosso projeto e possivelmente mais c√≥digo tamb√©m, vamos salvar a vers√£o atual do c√≥digo.

Adicione os arquivos que foram modificados com o comando `git add` e em seguida consolide a nova vers√£o com o comando `git commit -m "Adicionando circuit breaker"`.

N√£o esque√ßa de enviar as altera√ß√µes para o servidor remoto com o comando `git push`.

Nesse ponto temos uma API que melhoramos o tempo de resposta e aumentamos a robustez. S√≥ isto √© suficiente? Na verdade temos v√°rias outras t√©cnicas que podemos usar para melhorar a nossa API.

üòä Olha tudo que fizemos at√© agora!üéà Vamos continuar?

> üêÇ Uma api robusta deve estar preparada para lidar com falhas.
