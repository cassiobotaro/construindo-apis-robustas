{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udc02 Construindo API's robustas utilizando Python Neste tutorial vamos aprender a construir API's utilizando Python e FastAPI, integr\u00e1-las a servi\u00e7os externos e tamb\u00e9m a como torn\u00e1-las robustas. Discutiremos a import\u00e2ncia de uma boa documenta\u00e7\u00e3o e testes. Abordaremos conceitos como integra\u00e7\u00e3o com servi\u00e7os externos, integra\u00e7\u00e3o cont\u00ednua e testes automatizados. Analisaremos cen\u00e1rios onde precisaremos de uma melhor performance e algumas t\u00e9cnicas para alcan\u00e7ar este objetivo como chamadas a fun\u00e7\u00f5es ass\u00edncronas. Vamos tentar nos preparar para situa\u00e7\u00f5es ruins que possam acontecer e garantir que nosso sistema ser\u00e1 resiliente. O que veremos? Integra\u00e7\u00e3o com servi\u00e7os externos Integra\u00e7\u00e3o cont\u00ednua Testes automatizados Invoca\u00e7\u00e3o de processos ass\u00edncronos Circuit breaker Compartilhamento de mem\u00f3ria Pr\u00e9-requisitos Conhecimento b\u00e1sico de Python Conhecimento de desenvolvimento web Python 3.7+","title":"\u25b6\ufe0f Introdu\u00e7\u00e3o"},{"location":"#construindo-apis-robustas-utilizando-python","text":"Neste tutorial vamos aprender a construir API's utilizando Python e FastAPI, integr\u00e1-las a servi\u00e7os externos e tamb\u00e9m a como torn\u00e1-las robustas. Discutiremos a import\u00e2ncia de uma boa documenta\u00e7\u00e3o e testes. Abordaremos conceitos como integra\u00e7\u00e3o com servi\u00e7os externos, integra\u00e7\u00e3o cont\u00ednua e testes automatizados. Analisaremos cen\u00e1rios onde precisaremos de uma melhor performance e algumas t\u00e9cnicas para alcan\u00e7ar este objetivo como chamadas a fun\u00e7\u00f5es ass\u00edncronas. Vamos tentar nos preparar para situa\u00e7\u00f5es ruins que possam acontecer e garantir que nosso sistema ser\u00e1 resiliente.","title":"\ud83d\udc02 Construindo API's robustas utilizando Python"},{"location":"#o-que-veremos","text":"Integra\u00e7\u00e3o com servi\u00e7os externos Integra\u00e7\u00e3o cont\u00ednua Testes automatizados Invoca\u00e7\u00e3o de processos ass\u00edncronos Circuit breaker Compartilhamento de mem\u00f3ria","title":"O que veremos?"},{"location":"#pre-requisitos","text":"Conhecimento b\u00e1sico de Python Conhecimento de desenvolvimento web Python 3.7+","title":"Pr\u00e9-requisitos"},{"location":"ambientes_virtuais/","text":"\ud83d\udda5\ufe0f O ambiente virtual Iniciei um projeto e ele utiliza a biblioteca fastapi na vers\u00e3o 0.2, tr\u00eas meses depois fui iniciar outro e a vers\u00e3o do fastapi j\u00e1 era 0.3. Ser\u00e1 que n\u00e3o d\u00e1 problema se eu mudar no primeiro projeto? Ou ser\u00e1 que mudo no segundo? Para evitar este tipo de problema, vamos criar o que chamaremos de ambiente virtual. Na pr\u00e1tica o que vamos fazer \u00e9 instalar as bibliotecas em um diret\u00f3rio que est\u00e1 relacionado ao projeto. Assim cada projeto pode ter suas pr\u00f3prias bibliotecas na vers\u00e3o que quiser. Os comandos que utilizam o poetry, ir\u00e3o criar este ambiente virtual caso n\u00e3o exista. Este ambiente isolado ser\u00e1 visto como um diret\u00f3rio criado em uma pasta controlada pelo poetry embora isto pode ser alterado. \u21a9\ufe0f Voltar","title":"Ambientes virtuais"},{"location":"assincrono/","text":"\ud83d\udc06 Processos ass\u00edncronos \ud83d\udd25 O problema Vamos pensar um pouquinho na funcionalidade \"Dado um pedido, retornar os seus itens\" que j\u00e1 implementamos. Nosso algoritmo faz uma primeira requisi\u00e7\u00e3o para recuperar os pacotes de um pedido, para em seguida fazer uma nova requisi\u00e7\u00e3o para cada um dos pacotes e recuperar os seus itens. A primeira vista isto parece ok , mas temos alguns problemas escondidos a\u00ed. Enquanto estamos trabalhando em uma requisi\u00e7\u00e3o, todas as outras est\u00e3o aguardando. O uvicorn que \u00e9 o servidor que estamos utilizando at\u00e9 pode ter v\u00e1rios trabalhadores ( workers ) para mitigar um pouco isto, por\u00e9m caso v\u00e1rias requisi\u00e7\u00f5es aconte\u00e7am ao mesmo tempo, os trabalhadores podem ficar ocupados. Enquanto o servidor remoto n\u00e3o me responde, preciso ficar aguardando e depois da sua resposta eu refa\u00e7o este ciclo para cada um dos pacotes. Isto pode demorar um longo tempo. Vamos ver um desenho de como isto acontece: Se a primeira requisi\u00e7\u00e3o demorar 1 segundo, as demais tamb\u00e9m e se um pedido tiver 10 pacotes, demoraremos 11s para responder todos os itens. \ud83d\ude28 Nossa, isto n\u00e3o est\u00e1 parecendo muito legal...os valores de 1 segundo para cada requisi\u00e7\u00e3o pode ser um pouco exagerado, mas ajuda a evidenciar o problema. \ud83e\uddd1\u200d\ud83c\udfeb Demonstra\u00e7\u00e3o e Solu\u00e7\u00e3o Vamos fazer uma simula\u00e7\u00e3o utilizando c\u00f3digo para visualizar melhor este cen\u00e1rio. Crie um arquivo de exemplo como visto abaixo e execute-o para ver na pr\u00e1tica o que estamos falando. Para executa-lo utilize: poetry run python exemplo.py exemplo.py httpx . get ( \"https://httpbin.org/delay/1\" ) # simula a requisi\u00e7\u00e3o de um pedido print ( \"pedido recuperado\" ) for pacote in range ( 10 ): # simula o a itera\u00e7\u00e3o sobre os pacotes # simula a requisi\u00e7\u00e3o para buscar os itens de um pacote httpx . get ( \"https://httpbin.org/delay/1\" ) print ( f \"Os itens do pacote { pacote } foram recuperados.\" ) E como podemos fazer para melhorar?!?! Seria legal se pud\u00e9ssemos fazer v\u00e1rias requisi\u00e7\u00f5es ao mesmo tempo, isto podia poupar um tempo. N\u00e3o ficar\u00edamos ociosos enquanto aguardamos a api do Magalu responder. E na verdade podemos! Podemos pedir os itens dos pacotes ao mesmo tempo e aguardar enquanto eles chegam. exemplo_async.py import asyncio import httpx async def recupera_itens ( id_pacote , cliente ): # simula a requisi\u00e7\u00e3o para buscar os itens de um pacote await cliente . get ( \"https://httpbin.org/delay/1\" ) print ( f \"Os itens do pacote { id_pacote } foram recuperados.\" ) async def main (): async with httpx . AsyncClient () as cliente : await cliente . get ( \"https://httpbin.org/delay/1\" ) # simula a requisi\u00e7\u00e3o de um pedido print ( \"pedido recuperado\" ) await asyncio . gather ( * ( recupera_itens ( id_pacote , cliente ) for id_pacote in range ( 10 )) ) asyncio . run ( main ()) O c\u00f3digo se torna um pouco mais complexo, por\u00e9m temos um ganho consider\u00e1vel se compararmos as duas solu\u00e7\u00f5es. A primeira mudan\u00e7a \u00e9 adi\u00e7\u00e3o de um cliente ass\u00edncrono e mudan\u00e7a de nossa fun\u00e7\u00e3o para uma fun\u00e7\u00e3o ass\u00edncrona, com isso podemos fazer a requisi\u00e7\u00e3o de um pedido e enquanto espera, trabalhar em outra coisa. Depois transformamos a chamada de recupera\u00e7\u00e3o de itens em ass\u00edncronas tamb\u00e9m, assim todas podem ser feitas ao mesmo tempo e aguardaremos seus retornos com a fun\u00e7\u00e3o gather . O papel dessa fun\u00e7\u00e3o \u00e9 literalmente agrupar todas as respostas. Um detalhe que precisamos ficar atento aqui \u00e9 que toda fun\u00e7\u00e3o ass\u00edncrona \u00e9 aguardada com a express\u00e3o await e que a palavra reservada await sempre estar\u00e1 presente em uma fun\u00e7\u00e3o ass\u00edncrona. A \u00fanica fun\u00e7\u00e3o que n\u00e3o esperamos utilizando await \u00e9 a fun\u00e7\u00e3o main , que \u00e9 passada para a fun\u00e7\u00e3o run , que por baixo dos panos cria um loop de eventos necess\u00e1rio para executar fun\u00e7\u00f5es ass\u00edncronas e aguarda a execu\u00e7\u00e3o da mesma. \u26a1 Ficou interessado em ler mais sobre chamadas ass\u00edncronas em Python?? A documenta\u00e7\u00e3o do Python ou do FastAPI podem te ajudar. \u2328\ufe0f Modificando nossa API Para nossa sorte os frameworks escolhidos (httpx e fastapi) j\u00e1 s\u00e3o compat\u00edveis com chamadas ass\u00edncronas, e n\u00e3o precisaremos de grandes modifica\u00e7\u00f5es no c\u00f3digo. Mesmo assim, ao inv\u00e9s de modificar nossas fun\u00e7\u00f5es feitas at\u00e9 agora, vamos criar uma nova recuperar_itens_por_pedido por\u00e9m dessa vez ass\u00edncrona. Criaremos um arquivo com nome magalu_api_async com o conte\u00fado apresentado abaixo. O c\u00f3digo ser\u00e1 bem similar ao que j\u00e1 vimos no exemplo acima. api_produtos/magalu_api_async.py import asyncio import os from http import HTTPStatus from itertools import chain from uuid import UUID import httpx from api_pedidos.esquema import Item from api_pedidos.excecao import ( FalhaDeComunicacaoError , PedidoNaoEncontradoError , ) # tenant e apikey fixos somente para demonstra\u00e7\u00f5es APIKEY = os . environ . get ( \"APIKEY\" , \"coloque aqui sua apikey\" ) TENANT_ID = os . environ . get ( \"TENANT_ID\" , \"21fea73c-e244-497a-8540-be0d3c583596\" ) MAGALU_API_URL = \"https://alpha.api.magalu.com\" MAESTRO_SERVICE_URL = f \" { MAGALU_API_URL } /maestro/v1\" async def _recupera_itens_por_pacote ( cliente , uuid_do_pedido , uuid_do_pacote ): response = await cliente . get ( f \" { MAESTRO_SERVICE_URL } \" f \"/orders/ { uuid_do_pedido } /packages/ { uuid_do_pacote } /items\" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () return [ Item ( sku = item [ \"product\" ][ \"code\" ], description = item [ \"product\" ] . get ( \"description\" , \"\" ), image_url = item [ \"product\" ] . get ( \"image_url\" , \"\" ), reference = item [ \"product\" ] . get ( \"reference\" , \"\" ), quantity = item [ \"quantity\" ], ) for item in response . json () ] async def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID , ) -> list [ Item ]: async with httpx . AsyncClient () as cliente : try : response = await cliente . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { identificacao_do_pedido } \" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () pacotes = response . json ()[ \"packages\" ] itens = await asyncio . gather ( * ( _recupera_itens_por_pacote ( cliente , identificacao_do_pedido , pacote [ \"uuid\" ] ) for pacote in pacotes ) ) # truque para unir as listas em uma \u00fanica lista return list ( chain . from_iterable ( itens )) except httpx . HTTPStatusError as exc : if exc . response . status_code == HTTPStatus . NOT_FOUND : raise PedidoNaoEncontradoError () from exc raise exc except httpx . HTTPError as exc : # aqui poderiam ser tratados outros erros como autentica\u00e7\u00e3o raise FalhaDeComunicacaoError () from exc As mudan\u00e7as foram explicadas no exemplo anterior, mas repare que como cada requisi\u00e7\u00e3o retorna uma lista dos itens, precisamos agrupa-los em uma \u00fanica lista. \u00c9 como se tiv\u00e9ssemos uma lista de listas [[1, 2, 3], [4, 5, 6]] e vamos transformar em [1, 2, 3 ,4, 5, 6] . Isto \u00e9 feito no comando list(chain.from_iterable(itens)) . E o c\u00f3digo da api , o que precisamos modificar? Pode parecer estranho, mas n\u00e3o precisamos mudar muita coisa. api_produtos/api.py # ... from api_pedidos.magalu_api_async import recuperar_itens_por_pedido # ... @app . exception_handler ( PedidoNaoEncontradoError ) async def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): # ... @app . exception_handler ( FalhaDeComunicacaoError ) async def tratar_erro_falha_de_comunicacao ( request : Request , exc : FalhaDeComunicacaoError ): # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" , response_model = HealthCheckResponse , ) async def healthcheck (): # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , responses = { HTTPStatus . NOT_FOUND . value : { \"description\" : \"Pedido n\u00e3o encontrado\" , \"model\" : ErrorResponse , }, HTTPStatus . BAD_GATEWAY . value : { \"description\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" , \"model\" : ErrorResponse , }, }, summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ], ) async def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): # ... A adi\u00e7\u00e3o de async torna os nossos endpoints ass\u00edncronos embora caso eles ainda executem c\u00f3digos s\u00edncronos podemos ter o bloqueio dos nossos trabalhadores. Uma coisa interessante \u00e9 que como nossos testes s\u00e3o baseados em requisi\u00e7\u00f5es n\u00e3o precisamos altera-los. O comportamento da api deve ser o mesmo. Vamos rodar os testes para garantir que tudo est\u00e1 ok. \ud83d\udc81 Aqui n\u00e3o escrevemos os testes para o c\u00f3digo ass\u00edncrono, mas recomendamos que o fa\u00e7a. Uma ferramenta popularmente utilizada \u00e9 a AnyIO e o necess\u00e1rio para rodar testes ass\u00edncronos \u00e9 marcar as fun\u00e7\u00f5es como ass\u00edncronos. Leia mais detallhes aqui . \ud83d\udd27 Testando manualmente A nossa aplica\u00e7\u00e3o pode estar ainda rodando, mas caso n\u00e3o esteja vamos inicia-la. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Vamos testar alguns cen\u00e1rios? O que acontece se passar um valor qualquer ao inv\u00e9s de um uuid v\u00e1lido? http :8000/orders/invalido/items E um pedido que n\u00e3o existe? http :8000/orders/e3ae3598-8034-4374-8eed-bdca8c31d5a0/items Por fim vamos ver um pedido que existe. http :8000/orders/efb77dcf-d83c-4935-81ac-7be5f37e6cdc/items Voc\u00ea pode testar a falha do servidor remoto modificando a url no arquivo api_pedidos/magalu_api.py . \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/magalu_api_async.py exemplo.py exemplo_async.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar ao versionamento os arquivos novos e avisar modifica\u00e7\u00f5es em alguns j\u00e1 existentes. git add api_pedidos exemplo.py exemplo_async.py \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Modifica api para responder de forma ass\u00edncrona\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Nossa caixa de ferramentas acabou de ganhar uma ferramenta nova e pode ser bastante \u00fatil em outros momentos. Vamos seguir para a pr\u00f3xima t\u00e9cnica? Estou ansioso e voc\u00ea?! \ud83e\udd13 \ud83d\udc02 Uma api robusta deve se preocupar com o seu tempo de resposta.","title":"\ud83d\udc06 Processos ass\u00edncronos"},{"location":"assincrono/#processos-assincronos","text":"","title":"\ud83d\udc06 Processos ass\u00edncronos"},{"location":"assincrono/#o-problema","text":"Vamos pensar um pouquinho na funcionalidade \"Dado um pedido, retornar os seus itens\" que j\u00e1 implementamos. Nosso algoritmo faz uma primeira requisi\u00e7\u00e3o para recuperar os pacotes de um pedido, para em seguida fazer uma nova requisi\u00e7\u00e3o para cada um dos pacotes e recuperar os seus itens. A primeira vista isto parece ok , mas temos alguns problemas escondidos a\u00ed. Enquanto estamos trabalhando em uma requisi\u00e7\u00e3o, todas as outras est\u00e3o aguardando. O uvicorn que \u00e9 o servidor que estamos utilizando at\u00e9 pode ter v\u00e1rios trabalhadores ( workers ) para mitigar um pouco isto, por\u00e9m caso v\u00e1rias requisi\u00e7\u00f5es aconte\u00e7am ao mesmo tempo, os trabalhadores podem ficar ocupados. Enquanto o servidor remoto n\u00e3o me responde, preciso ficar aguardando e depois da sua resposta eu refa\u00e7o este ciclo para cada um dos pacotes. Isto pode demorar um longo tempo. Vamos ver um desenho de como isto acontece: Se a primeira requisi\u00e7\u00e3o demorar 1 segundo, as demais tamb\u00e9m e se um pedido tiver 10 pacotes, demoraremos 11s para responder todos os itens. \ud83d\ude28 Nossa, isto n\u00e3o est\u00e1 parecendo muito legal...os valores de 1 segundo para cada requisi\u00e7\u00e3o pode ser um pouco exagerado, mas ajuda a evidenciar o problema.","title":"\ud83d\udd25 O problema"},{"location":"assincrono/#demonstracao-e-solucao","text":"Vamos fazer uma simula\u00e7\u00e3o utilizando c\u00f3digo para visualizar melhor este cen\u00e1rio. Crie um arquivo de exemplo como visto abaixo e execute-o para ver na pr\u00e1tica o que estamos falando. Para executa-lo utilize: poetry run python exemplo.py exemplo.py httpx . get ( \"https://httpbin.org/delay/1\" ) # simula a requisi\u00e7\u00e3o de um pedido print ( \"pedido recuperado\" ) for pacote in range ( 10 ): # simula o a itera\u00e7\u00e3o sobre os pacotes # simula a requisi\u00e7\u00e3o para buscar os itens de um pacote httpx . get ( \"https://httpbin.org/delay/1\" ) print ( f \"Os itens do pacote { pacote } foram recuperados.\" ) E como podemos fazer para melhorar?!?! Seria legal se pud\u00e9ssemos fazer v\u00e1rias requisi\u00e7\u00f5es ao mesmo tempo, isto podia poupar um tempo. N\u00e3o ficar\u00edamos ociosos enquanto aguardamos a api do Magalu responder. E na verdade podemos! Podemos pedir os itens dos pacotes ao mesmo tempo e aguardar enquanto eles chegam. exemplo_async.py import asyncio import httpx async def recupera_itens ( id_pacote , cliente ): # simula a requisi\u00e7\u00e3o para buscar os itens de um pacote await cliente . get ( \"https://httpbin.org/delay/1\" ) print ( f \"Os itens do pacote { id_pacote } foram recuperados.\" ) async def main (): async with httpx . AsyncClient () as cliente : await cliente . get ( \"https://httpbin.org/delay/1\" ) # simula a requisi\u00e7\u00e3o de um pedido print ( \"pedido recuperado\" ) await asyncio . gather ( * ( recupera_itens ( id_pacote , cliente ) for id_pacote in range ( 10 )) ) asyncio . run ( main ()) O c\u00f3digo se torna um pouco mais complexo, por\u00e9m temos um ganho consider\u00e1vel se compararmos as duas solu\u00e7\u00f5es. A primeira mudan\u00e7a \u00e9 adi\u00e7\u00e3o de um cliente ass\u00edncrono e mudan\u00e7a de nossa fun\u00e7\u00e3o para uma fun\u00e7\u00e3o ass\u00edncrona, com isso podemos fazer a requisi\u00e7\u00e3o de um pedido e enquanto espera, trabalhar em outra coisa. Depois transformamos a chamada de recupera\u00e7\u00e3o de itens em ass\u00edncronas tamb\u00e9m, assim todas podem ser feitas ao mesmo tempo e aguardaremos seus retornos com a fun\u00e7\u00e3o gather . O papel dessa fun\u00e7\u00e3o \u00e9 literalmente agrupar todas as respostas. Um detalhe que precisamos ficar atento aqui \u00e9 que toda fun\u00e7\u00e3o ass\u00edncrona \u00e9 aguardada com a express\u00e3o await e que a palavra reservada await sempre estar\u00e1 presente em uma fun\u00e7\u00e3o ass\u00edncrona. A \u00fanica fun\u00e7\u00e3o que n\u00e3o esperamos utilizando await \u00e9 a fun\u00e7\u00e3o main , que \u00e9 passada para a fun\u00e7\u00e3o run , que por baixo dos panos cria um loop de eventos necess\u00e1rio para executar fun\u00e7\u00f5es ass\u00edncronas e aguarda a execu\u00e7\u00e3o da mesma. \u26a1 Ficou interessado em ler mais sobre chamadas ass\u00edncronas em Python?? A documenta\u00e7\u00e3o do Python ou do FastAPI podem te ajudar.","title":"\ud83e\uddd1\u200d\ud83c\udfeb Demonstra\u00e7\u00e3o e Solu\u00e7\u00e3o"},{"location":"assincrono/#modificando-nossa-api","text":"Para nossa sorte os frameworks escolhidos (httpx e fastapi) j\u00e1 s\u00e3o compat\u00edveis com chamadas ass\u00edncronas, e n\u00e3o precisaremos de grandes modifica\u00e7\u00f5es no c\u00f3digo. Mesmo assim, ao inv\u00e9s de modificar nossas fun\u00e7\u00f5es feitas at\u00e9 agora, vamos criar uma nova recuperar_itens_por_pedido por\u00e9m dessa vez ass\u00edncrona. Criaremos um arquivo com nome magalu_api_async com o conte\u00fado apresentado abaixo. O c\u00f3digo ser\u00e1 bem similar ao que j\u00e1 vimos no exemplo acima. api_produtos/magalu_api_async.py import asyncio import os from http import HTTPStatus from itertools import chain from uuid import UUID import httpx from api_pedidos.esquema import Item from api_pedidos.excecao import ( FalhaDeComunicacaoError , PedidoNaoEncontradoError , ) # tenant e apikey fixos somente para demonstra\u00e7\u00f5es APIKEY = os . environ . get ( \"APIKEY\" , \"coloque aqui sua apikey\" ) TENANT_ID = os . environ . get ( \"TENANT_ID\" , \"21fea73c-e244-497a-8540-be0d3c583596\" ) MAGALU_API_URL = \"https://alpha.api.magalu.com\" MAESTRO_SERVICE_URL = f \" { MAGALU_API_URL } /maestro/v1\" async def _recupera_itens_por_pacote ( cliente , uuid_do_pedido , uuid_do_pacote ): response = await cliente . get ( f \" { MAESTRO_SERVICE_URL } \" f \"/orders/ { uuid_do_pedido } /packages/ { uuid_do_pacote } /items\" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () return [ Item ( sku = item [ \"product\" ][ \"code\" ], description = item [ \"product\" ] . get ( \"description\" , \"\" ), image_url = item [ \"product\" ] . get ( \"image_url\" , \"\" ), reference = item [ \"product\" ] . get ( \"reference\" , \"\" ), quantity = item [ \"quantity\" ], ) for item in response . json () ] async def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID , ) -> list [ Item ]: async with httpx . AsyncClient () as cliente : try : response = await cliente . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { identificacao_do_pedido } \" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () pacotes = response . json ()[ \"packages\" ] itens = await asyncio . gather ( * ( _recupera_itens_por_pacote ( cliente , identificacao_do_pedido , pacote [ \"uuid\" ] ) for pacote in pacotes ) ) # truque para unir as listas em uma \u00fanica lista return list ( chain . from_iterable ( itens )) except httpx . HTTPStatusError as exc : if exc . response . status_code == HTTPStatus . NOT_FOUND : raise PedidoNaoEncontradoError () from exc raise exc except httpx . HTTPError as exc : # aqui poderiam ser tratados outros erros como autentica\u00e7\u00e3o raise FalhaDeComunicacaoError () from exc As mudan\u00e7as foram explicadas no exemplo anterior, mas repare que como cada requisi\u00e7\u00e3o retorna uma lista dos itens, precisamos agrupa-los em uma \u00fanica lista. \u00c9 como se tiv\u00e9ssemos uma lista de listas [[1, 2, 3], [4, 5, 6]] e vamos transformar em [1, 2, 3 ,4, 5, 6] . Isto \u00e9 feito no comando list(chain.from_iterable(itens)) . E o c\u00f3digo da api , o que precisamos modificar? Pode parecer estranho, mas n\u00e3o precisamos mudar muita coisa. api_produtos/api.py # ... from api_pedidos.magalu_api_async import recuperar_itens_por_pedido # ... @app . exception_handler ( PedidoNaoEncontradoError ) async def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): # ... @app . exception_handler ( FalhaDeComunicacaoError ) async def tratar_erro_falha_de_comunicacao ( request : Request , exc : FalhaDeComunicacaoError ): # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" , response_model = HealthCheckResponse , ) async def healthcheck (): # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , responses = { HTTPStatus . NOT_FOUND . value : { \"description\" : \"Pedido n\u00e3o encontrado\" , \"model\" : ErrorResponse , }, HTTPStatus . BAD_GATEWAY . value : { \"description\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" , \"model\" : ErrorResponse , }, }, summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ], ) async def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): # ... A adi\u00e7\u00e3o de async torna os nossos endpoints ass\u00edncronos embora caso eles ainda executem c\u00f3digos s\u00edncronos podemos ter o bloqueio dos nossos trabalhadores. Uma coisa interessante \u00e9 que como nossos testes s\u00e3o baseados em requisi\u00e7\u00f5es n\u00e3o precisamos altera-los. O comportamento da api deve ser o mesmo. Vamos rodar os testes para garantir que tudo est\u00e1 ok. \ud83d\udc81 Aqui n\u00e3o escrevemos os testes para o c\u00f3digo ass\u00edncrono, mas recomendamos que o fa\u00e7a. Uma ferramenta popularmente utilizada \u00e9 a AnyIO e o necess\u00e1rio para rodar testes ass\u00edncronos \u00e9 marcar as fun\u00e7\u00f5es como ass\u00edncronos. Leia mais detallhes aqui .","title":"\u2328\ufe0f Modificando nossa API"},{"location":"assincrono/#testando-manualmente","text":"A nossa aplica\u00e7\u00e3o pode estar ainda rodando, mas caso n\u00e3o esteja vamos inicia-la. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Vamos testar alguns cen\u00e1rios? O que acontece se passar um valor qualquer ao inv\u00e9s de um uuid v\u00e1lido? http :8000/orders/invalido/items E um pedido que n\u00e3o existe? http :8000/orders/e3ae3598-8034-4374-8eed-bdca8c31d5a0/items Por fim vamos ver um pedido que existe. http :8000/orders/efb77dcf-d83c-4935-81ac-7be5f37e6cdc/items Voc\u00ea pode testar a falha do servidor remoto modificando a url no arquivo api_pedidos/magalu_api.py .","title":"\ud83d\udd27 Testando manualmente"},{"location":"assincrono/#salvando-a-versao-atual-do-codigo","text":"Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/magalu_api_async.py exemplo.py exemplo_async.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar ao versionamento os arquivos novos e avisar modifica\u00e7\u00f5es em alguns j\u00e1 existentes. git add api_pedidos exemplo.py exemplo_async.py \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Modifica api para responder de forma ass\u00edncrona\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Nossa caixa de ferramentas acabou de ganhar uma ferramenta nova e pode ser bastante \u00fatil em outros momentos. Vamos seguir para a pr\u00f3xima t\u00e9cnica? Estou ansioso e voc\u00ea?! \ud83e\udd13 \ud83d\udc02 Uma api robusta deve se preocupar com o seu tempo de resposta.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"avancadas/","text":"\ud83e\uddb8 T\u00e9cnicas (um pouco) mais avan\u00e7adas \ud83d\udeb1 Rate limit O que \u00e9 ? Rate Limit \u00e9 a limita\u00e7\u00e3o de solicita\u00e7\u00e3o entre um controlador de origem e uma interface destino. No mundo de servi\u00e7os web podemos dizer que Rate Limit \u00e9 a limita\u00e7\u00e3o de requisi\u00e7\u00f5es de um usu\u00e1rio (client) para uma WebAPI. Quando utilizar Utiliza a estrat\u00e9gia de Rate Limit no ambiente de WebAPIs para evitar ataques de invasores, quando o mesmo fica explorando as vulnerabilidades de seguran\u00e7a do sistema para infectar e controlar m\u00e1quinas e dispositivos. Dicas / Links / Ferramentas https://pypi.org/project/fastapi-limiter/ https://pypi.org/project/slowapi/ \ud83d\udd12 Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o O que \u00e9 ? Autentica\u00e7\u00e3o \u00e9 o processo do sistema para verificar a identidade virtual do usu\u00e1rio o client, normalmente baseado em um login e senha. Autoriza\u00e7\u00e3o \u00e9 o processo que permite o usu\u00e1rio ou client acessar uma ou mais funcionalidades e recursos do sistema. Quando utilizar? Colocar um processo de Autentica\u00e7\u00e3o na sua \u00e9 WebAPI refor\u00e7ar a seguran\u00e7a da mesma evitando que usu\u00e1rios maliciosos consigam acess\u00e1-la e causar algum impacto no sistema. O processo de Autoriza\u00e7\u00e3o vem na sequ\u00eancia, a import\u00e2ncia de adotar esse processo \u00e9 que mesmo os usu\u00e1rios que consigam se autenticar n\u00e3o necessariamente eles ter\u00e3o acessos \u00e0s informa\u00e7\u00f5es e recursos. Na Autoriza\u00e7\u00e3o voc\u00ea consegue limitar o usu\u00e1rio nos acessos aos recursos e os dados do sistema. Dicas / Links / Ferramentas https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/ https://pypi.org/project/python-oauth2/ https://pypi.org/project/python-openid/ https://www.keycloak.org/ \ud83d\uddfa\ufe0f Hateoas O que \u00e9 ? Hateoas (Hypermedia As the Engine Of Application State) vem da palavra Hypermedia, onde os documentos s\u00e3o integrados atrav\u00e9s de links. Ou seja, quando clicamos em uma frase ou imagem em um site e \u00e9 direcionado para outra p\u00e1gina essa a\u00e7\u00e3o acontece de forma impl\u00edcita ao usu\u00e1rio e utilizando hyperlink. Em WebAPIs \u00e9 a capacidade de linkar recursos atrav\u00e9s de links dentro do documento json. Os clients n\u00e3o precisam conhecer as URLs de recursos, apenas de entrypoint. Ou seja, a API passa a fornecer links em atributos json que indicar\u00e3o aos clients como navegar atrav\u00e9s dos seus recursos. Quando utilizar? A utiliza\u00e7\u00e3o de Hateoas acontece quando o Frontend (client) n\u00e3o precisa ter as regras para saber consumir as API. Pois, no pr\u00f3prio documento json tem os atributos existentes com os poss\u00edveis links para a navega\u00e7\u00e3o dos pr\u00f3ximos recursos. Isso \u00e9 importante quando temos APIs abertas e os clients n\u00e3o conhecem as regras de neg\u00f3cio do server (backend). Tamb\u00e9m podemos utilizar em times grandes que trabalham provendo recursos para v\u00e1rias equipes atrav\u00e9s de WebAPIs. Dicas / Links / Ferramentas https://restful-api-design.readthedocs.io/en/latest/urls.html https://pypi.org/project/ripozo/ \ud83d\udcf0 Log O que \u00e9 ? Log nada mais \u00e9 que a apresenta\u00e7\u00e3o das informa\u00e7\u00f5es de etapas percorridas do sistema ou a\u00e7\u00f5es que o algoritmo executou em algum processo. Essas informa\u00e7\u00f5es s\u00e3o registros que ficam gravados em arquivos e ajudam a identificar o comportamento do sistema e at\u00e9 identifica\u00e7\u00e3o de erros. Quando utilizar? Sempre! Mas depende do tipo de log. Isso mesmo que voc\u00ea leu, depende do tipo ou o termo correto n\u00edvel de log e o ambiente que a aplica\u00e7\u00e3o est\u00e1. Na fase de desenvolvimento utiliza-se o log no n\u00edvel debug, esse n\u00edvel ajuda a percorrer o algoritmo com maior frequ\u00eancia e acompanhar em detalhes. Em ambientes de teste e de produ\u00e7\u00e3o utiliza o log no n\u00edvel de erro ou info. Esses n\u00edveis possibilitam ter os registros de erros da aplica\u00e7\u00e3o ou alguma informa\u00e7\u00e3o relevante, sem poluir os registros. Dicas / Links / Ferramentas https://docs.python.org/3/library/logging.html https://www.geeksforgeeks.org/logging-in-python/ Logging \ud83d\udcc4 Pagina\u00e7\u00e3o O que \u00e9 ? Pagina\u00e7\u00e3o \u00e9 a estrat\u00e9gia de dividir em p\u00e1ginas as informa\u00e7\u00f5es solicitadas. Em WebAPI \u00e9 a capacidade de dividir em partes a quantidade de informa\u00e7\u00f5es retornada da requisi\u00e7\u00e3o realizada. Sendo que a cada requisi\u00e7\u00e3o solicitar\u00e1 a informa\u00e7\u00e3o da p\u00e1gina e o retorno \u00e9 referente a quantidade configurada, n\u00e3o precisando retornar todas as informa\u00e7\u00f5es. Quando utilizar? Normalmente \u00e9 utilizado em recursos que prov\u00ea uma listagem de resultados. Esse recurso, por padr\u00e3o, exige um alto processamento para retornar todas as informa\u00e7\u00f5es e consequentemente sobrecarrega o processamento da rede. Para isso \u00e9 aplicado a pagina\u00e7\u00e3o em sua API especificando apenas a quantidade limite de cada p\u00e1gina. Dicas / Links / Ferramentas https://uriyyo-fastapi-pagination.netlify.app/ https://fastapi.tiangolo.com/pt/tutorial/query-params/?h=limit https://alpha.dev.magalu.com/apis/maestro \ud83d\uddc4\ufe0f Cache O que \u00e9 ? \u00c9 o local de armazenamento de dados tempor\u00e1rios que pode ser acessado sem a necessidade de I/O ou utiliza\u00e7\u00e3o de recursos de rede. Quando utilizar? Quando precisa obter dados com frequ\u00eancia e que n\u00e3o mudam. Caso adote a estrat\u00e9gia de um Banco de Dados a opera\u00e7\u00e3o ser\u00e1 vinculada um I/O, utiliza\u00e7\u00e3o de recursos de rede e afeta o desempenho da aplica\u00e7\u00e3o. Adotando uma estrat\u00e9gia de cache da aplica\u00e7\u00e3o, al\u00e9m de n\u00e3o necessitar os pontos anteriores, h\u00e1 uma melhora de performance do sistema. Esses dados podem ser como token de sess\u00e3o, c\u00f3digo de identifica\u00e7\u00e3o (id) de entidade, nome de usu\u00e1rio ou qualquer outro dado que ser\u00e1 usada constantemente pelo algor\u00edtimo e n\u00e3o sofrer\u00e1 altera\u00e7\u00e3o. Dicas / Links / Ferramentas https://github.com/long2ice/fastapi-cache https://docs.python.org/pt-br/3.10/library/functools.html https://medium.com/fintechexplained/advanced-python-how-to-implement-caching-in-python-application-9d0a4136b845 \ud83e\udde0 Mem\u00f3ria Compartilhada (n\u00edvel avan\u00e7ado) O que \u00e9 ? \u00c9 o compartilhamento de dados em objeto de mem\u00f3ria entre threads e pods, utilizando apenas um \u00fanico recurso para este dado. Ou seja, um respectivo dado foi armazenado em disco alocando um determinado tamanho de mem\u00f3ria. Este mesmo dado poder\u00e1 ser compartilhado por n threads (processos) da mesma aplica\u00e7\u00e3o ou em pods diferente do mesmo recurso. N\u00e3o tendo a necessidade de realizar aloca\u00e7\u00f5es de mem\u00f3rias em diversos processamentos repetindo o mesmo dado. Quando utilizar? Quando tiver a necessidade de um dado ser acessado para leitura por alguns processos. Como, por exemplo, para a thread obter um token de client credential ao inv\u00e9s de ir no vault poder\u00e1 ser compartilhado atrav\u00e9s de shared memory (sem ttl). Dicas / Links / Ferramentas https://github.com/luizalabs/shared-memory-dict https://docs.python.org/3/library/multiprocessing.shared_memory.html https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes \u2699\ufe0f Tarefa em Background (worker, mensageria, t\u00f3picos) O que \u00e9 ? Tarefas em background podem ser consideradas como tarefas ass\u00edncronas. Os processos ass\u00edncronos s\u00e3o processos que n\u00e3o dependem de uma resposta da realiza\u00e7\u00e3o da tarefa, como vemos em uma requisi\u00e7\u00e3o de uma WebAPI, e s\u00e3o normalmente orientadas a mensagens e eventos. Quando utilizar? A utiliza\u00e7\u00e3o de tarefa em background pode ser utilizado para processar dados em lotes, leituras de arquivos, processos com muitas integra\u00e7\u00f5es de recursos e servi\u00e7os, e tarefas que dever\u00e3o ser executadas periodicamente em processos agendados. Dicas / Links / Ferramentas https://kafka.apache.org/ https://www.rabbitmq.com/ https://kafka-python.readthedocs.io/en/master/usage.html https://pika.readthedocs.io/en/0.10.0/","title":"\ud83e\uddb8 T\u00e9cnicas (um pouco mais avan\u00e7adas)"},{"location":"avancadas/#tecnicas-um-pouco-mais-avancadas","text":"","title":"\ud83e\uddb8 T\u00e9cnicas (um pouco) mais avan\u00e7adas"},{"location":"avancadas/#rate-limit","text":"","title":"\ud83d\udeb1 Rate limit"},{"location":"avancadas/#o-que-e","text":"Rate Limit \u00e9 a limita\u00e7\u00e3o de solicita\u00e7\u00e3o entre um controlador de origem e uma interface destino. No mundo de servi\u00e7os web podemos dizer que Rate Limit \u00e9 a limita\u00e7\u00e3o de requisi\u00e7\u00f5es de um usu\u00e1rio (client) para uma WebAPI.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar","text":"Utiliza a estrat\u00e9gia de Rate Limit no ambiente de WebAPIs para evitar ataques de invasores, quando o mesmo fica explorando as vulnerabilidades de seguran\u00e7a do sistema para infectar e controlar m\u00e1quinas e dispositivos.","title":"Quando utilizar"},{"location":"avancadas/#dicas-links-ferramentas","text":"https://pypi.org/project/fastapi-limiter/ https://pypi.org/project/slowapi/","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#autenticacao-e-autorizacao","text":"","title":"\ud83d\udd12 Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o"},{"location":"avancadas/#o-que-e_1","text":"Autentica\u00e7\u00e3o \u00e9 o processo do sistema para verificar a identidade virtual do usu\u00e1rio o client, normalmente baseado em um login e senha. Autoriza\u00e7\u00e3o \u00e9 o processo que permite o usu\u00e1rio ou client acessar uma ou mais funcionalidades e recursos do sistema.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_1","text":"Colocar um processo de Autentica\u00e7\u00e3o na sua \u00e9 WebAPI refor\u00e7ar a seguran\u00e7a da mesma evitando que usu\u00e1rios maliciosos consigam acess\u00e1-la e causar algum impacto no sistema. O processo de Autoriza\u00e7\u00e3o vem na sequ\u00eancia, a import\u00e2ncia de adotar esse processo \u00e9 que mesmo os usu\u00e1rios que consigam se autenticar n\u00e3o necessariamente eles ter\u00e3o acessos \u00e0s informa\u00e7\u00f5es e recursos. Na Autoriza\u00e7\u00e3o voc\u00ea consegue limitar o usu\u00e1rio nos acessos aos recursos e os dados do sistema.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_1","text":"https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/ https://pypi.org/project/python-oauth2/ https://pypi.org/project/python-openid/ https://www.keycloak.org/","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#hateoas","text":"","title":"\ud83d\uddfa\ufe0f Hateoas"},{"location":"avancadas/#o-que-e_2","text":"Hateoas (Hypermedia As the Engine Of Application State) vem da palavra Hypermedia, onde os documentos s\u00e3o integrados atrav\u00e9s de links. Ou seja, quando clicamos em uma frase ou imagem em um site e \u00e9 direcionado para outra p\u00e1gina essa a\u00e7\u00e3o acontece de forma impl\u00edcita ao usu\u00e1rio e utilizando hyperlink. Em WebAPIs \u00e9 a capacidade de linkar recursos atrav\u00e9s de links dentro do documento json. Os clients n\u00e3o precisam conhecer as URLs de recursos, apenas de entrypoint. Ou seja, a API passa a fornecer links em atributos json que indicar\u00e3o aos clients como navegar atrav\u00e9s dos seus recursos.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_2","text":"A utiliza\u00e7\u00e3o de Hateoas acontece quando o Frontend (client) n\u00e3o precisa ter as regras para saber consumir as API. Pois, no pr\u00f3prio documento json tem os atributos existentes com os poss\u00edveis links para a navega\u00e7\u00e3o dos pr\u00f3ximos recursos. Isso \u00e9 importante quando temos APIs abertas e os clients n\u00e3o conhecem as regras de neg\u00f3cio do server (backend). Tamb\u00e9m podemos utilizar em times grandes que trabalham provendo recursos para v\u00e1rias equipes atrav\u00e9s de WebAPIs.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_2","text":"https://restful-api-design.readthedocs.io/en/latest/urls.html https://pypi.org/project/ripozo/","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#log","text":"","title":"\ud83d\udcf0 Log"},{"location":"avancadas/#o-que-e_3","text":"Log nada mais \u00e9 que a apresenta\u00e7\u00e3o das informa\u00e7\u00f5es de etapas percorridas do sistema ou a\u00e7\u00f5es que o algoritmo executou em algum processo. Essas informa\u00e7\u00f5es s\u00e3o registros que ficam gravados em arquivos e ajudam a identificar o comportamento do sistema e at\u00e9 identifica\u00e7\u00e3o de erros.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_3","text":"Sempre! Mas depende do tipo de log. Isso mesmo que voc\u00ea leu, depende do tipo ou o termo correto n\u00edvel de log e o ambiente que a aplica\u00e7\u00e3o est\u00e1. Na fase de desenvolvimento utiliza-se o log no n\u00edvel debug, esse n\u00edvel ajuda a percorrer o algoritmo com maior frequ\u00eancia e acompanhar em detalhes. Em ambientes de teste e de produ\u00e7\u00e3o utiliza o log no n\u00edvel de erro ou info. Esses n\u00edveis possibilitam ter os registros de erros da aplica\u00e7\u00e3o ou alguma informa\u00e7\u00e3o relevante, sem poluir os registros.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_3","text":"https://docs.python.org/3/library/logging.html https://www.geeksforgeeks.org/logging-in-python/ Logging","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#paginacao","text":"","title":"\ud83d\udcc4 Pagina\u00e7\u00e3o"},{"location":"avancadas/#o-que-e_4","text":"Pagina\u00e7\u00e3o \u00e9 a estrat\u00e9gia de dividir em p\u00e1ginas as informa\u00e7\u00f5es solicitadas. Em WebAPI \u00e9 a capacidade de dividir em partes a quantidade de informa\u00e7\u00f5es retornada da requisi\u00e7\u00e3o realizada. Sendo que a cada requisi\u00e7\u00e3o solicitar\u00e1 a informa\u00e7\u00e3o da p\u00e1gina e o retorno \u00e9 referente a quantidade configurada, n\u00e3o precisando retornar todas as informa\u00e7\u00f5es.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_4","text":"Normalmente \u00e9 utilizado em recursos que prov\u00ea uma listagem de resultados. Esse recurso, por padr\u00e3o, exige um alto processamento para retornar todas as informa\u00e7\u00f5es e consequentemente sobrecarrega o processamento da rede. Para isso \u00e9 aplicado a pagina\u00e7\u00e3o em sua API especificando apenas a quantidade limite de cada p\u00e1gina.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_4","text":"https://uriyyo-fastapi-pagination.netlify.app/ https://fastapi.tiangolo.com/pt/tutorial/query-params/?h=limit https://alpha.dev.magalu.com/apis/maestro","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#cache","text":"","title":"\ud83d\uddc4\ufe0f Cache"},{"location":"avancadas/#o-que-e_5","text":"\u00c9 o local de armazenamento de dados tempor\u00e1rios que pode ser acessado sem a necessidade de I/O ou utiliza\u00e7\u00e3o de recursos de rede.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_5","text":"Quando precisa obter dados com frequ\u00eancia e que n\u00e3o mudam. Caso adote a estrat\u00e9gia de um Banco de Dados a opera\u00e7\u00e3o ser\u00e1 vinculada um I/O, utiliza\u00e7\u00e3o de recursos de rede e afeta o desempenho da aplica\u00e7\u00e3o. Adotando uma estrat\u00e9gia de cache da aplica\u00e7\u00e3o, al\u00e9m de n\u00e3o necessitar os pontos anteriores, h\u00e1 uma melhora de performance do sistema. Esses dados podem ser como token de sess\u00e3o, c\u00f3digo de identifica\u00e7\u00e3o (id) de entidade, nome de usu\u00e1rio ou qualquer outro dado que ser\u00e1 usada constantemente pelo algor\u00edtimo e n\u00e3o sofrer\u00e1 altera\u00e7\u00e3o.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_5","text":"https://github.com/long2ice/fastapi-cache https://docs.python.org/pt-br/3.10/library/functools.html https://medium.com/fintechexplained/advanced-python-how-to-implement-caching-in-python-application-9d0a4136b845","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#memoria-compartilhada-nivel-avancado","text":"","title":"\ud83e\udde0 Mem\u00f3ria Compartilhada (n\u00edvel avan\u00e7ado)"},{"location":"avancadas/#o-que-e_6","text":"\u00c9 o compartilhamento de dados em objeto de mem\u00f3ria entre threads e pods, utilizando apenas um \u00fanico recurso para este dado. Ou seja, um respectivo dado foi armazenado em disco alocando um determinado tamanho de mem\u00f3ria. Este mesmo dado poder\u00e1 ser compartilhado por n threads (processos) da mesma aplica\u00e7\u00e3o ou em pods diferente do mesmo recurso. N\u00e3o tendo a necessidade de realizar aloca\u00e7\u00f5es de mem\u00f3rias em diversos processamentos repetindo o mesmo dado.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_6","text":"Quando tiver a necessidade de um dado ser acessado para leitura por alguns processos. Como, por exemplo, para a thread obter um token de client credential ao inv\u00e9s de ir no vault poder\u00e1 ser compartilhado atrav\u00e9s de shared memory (sem ttl).","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_6","text":"https://github.com/luizalabs/shared-memory-dict https://docs.python.org/3/library/multiprocessing.shared_memory.html https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes","title":"Dicas / Links / Ferramentas"},{"location":"avancadas/#tarefa-em-background-worker-mensageria-topicos","text":"","title":"\u2699\ufe0f Tarefa em Background (worker, mensageria, t\u00f3picos)"},{"location":"avancadas/#o-que-e_7","text":"Tarefas em background podem ser consideradas como tarefas ass\u00edncronas. Os processos ass\u00edncronos s\u00e3o processos que n\u00e3o dependem de uma resposta da realiza\u00e7\u00e3o da tarefa, como vemos em uma requisi\u00e7\u00e3o de uma WebAPI, e s\u00e3o normalmente orientadas a mensagens e eventos.","title":"O que \u00e9 ?"},{"location":"avancadas/#quando-utilizar_7","text":"A utiliza\u00e7\u00e3o de tarefa em background pode ser utilizado para processar dados em lotes, leituras de arquivos, processos com muitas integra\u00e7\u00f5es de recursos e servi\u00e7os, e tarefas que dever\u00e3o ser executadas periodicamente em processos agendados.","title":"Quando utilizar?"},{"location":"avancadas/#dicas-links-ferramentas_7","text":"https://kafka.apache.org/ https://www.rabbitmq.com/ https://kafka-python.readthedocs.io/en/master/usage.html https://pika.readthedocs.io/en/0.10.0/","title":"Dicas / Links / Ferramentas"},{"location":"breaker/","text":"\ud83d\udd0c Circuit breaker \ud83d\udd25 O problema Sistemas falham! E devemos estar preparados pra quando isto ocorrer. Se tudo foi implementado at\u00e9 o momento (incluindo os desafios), n\u00f3s temos integra\u00e7\u00f5es com dois sistemas distintos. E se um deles falhar? ou ambos? Vamos parar todo o nosso sistema por conta disto? E como saber se n\u00e3o \u00e9 apenas uma instabilidade? E se \u00e9 uma falha de rede? Voc\u00ea talvez j\u00e1 tenha ouvido falar em retentativas em cen\u00e1rios de integra\u00e7\u00e3o, mas essas retentativas podem degradar ainda mais o sistema ao qual estamos integrando. \ud83d\ude40 E agora? O que podemos fazer? E se pux\u00e1ssemos o plug que liga nosso sistema ao sistema externo temporariamente? O que vamos falar aqui se aplica a integra\u00e7\u00f5es com sistemas de terceiros ou sistemas distribu\u00eddos internos. \ud83d\udd0c Circuit breaker A tradu\u00e7\u00e3o seria, \"disjuntor\", e seu papel na eletr\u00f4nica \u00e9 abrir o circuito que apresenta falha evitando uma sobrecarga de seus componentes. Esse termo tamb\u00e9m \u00e9 utilizado na bolsa de valores para quando h\u00e1 uma grande instabilidade (uma forte queda por exemplo), assim a bolsa de valores interrompe as negocia\u00e7\u00f5es temporariamente, evitando maiores perdas nesses momentos. Notaram uma semelhan\u00e7a na utiliza\u00e7\u00e3o do conceito? Temos uma falha e uma \"abertura\" do circuito para evitar maiores danos. Assim funciona o circuit breaker na computa\u00e7\u00e3o. Quando falamos em abrir um circuito, estamos falando na verdade em interromper a comunica\u00e7\u00e3o entre sistemas (temporariamente). Nygard em seu livro Release It explica bem o circuit breaker. Quote [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system. Nosso sistema tem os seguintes estados: Estado fechado: \u00e9 o estado onde tudo est\u00e1 funcionando normalmente e as requisi\u00e7\u00f5es ser\u00e3o feitas normalmente. Quando alguma condi\u00e7\u00e3o de falha \u00e9 detectada, o circuito \u00e9 aberto. Estado aberto: \u00e9 o estado onde o circuito est\u00e1 aberto e as requisi\u00e7\u00f5es n\u00e3o ser\u00e3o executadas. Um erro ser\u00e1 retornado ou uma informa\u00e7\u00e3o presente em cache. Estado semi aberto: \u00e9 o estado posterior ao estado aberto. Um teste \u00e9 feito para verificar a condi\u00e7\u00e3o atual do circuito, se uma falha ocorrer, o estado ser\u00e1 alternado para aberto novamente, mas se for bem-sucedido, ele volta para o estado fechado. \ud83e\uddd1\u200d\ud83c\udfeb Demonstra\u00e7\u00e3o e Solu\u00e7\u00e3o Vamos fazer uma simula\u00e7\u00e3o utilizando c\u00f3digo para visualisar melhor este cen\u00e1rio. Crie um arquivo de exemplo como visto abaixo e execute-o para ver na pr\u00e1tica o que estamos falando. Para executa-lo utilize: python exemplo_circuito_breaker.py exemplo_circuito_breaker.py import asyncio import httpx async def recupera_produto ( codigo ): print ( f \"Recuperando produto de c\u00f3digo { codigo } \" ) try : async with httpx . AsyncClient () as cliente : resposta = await cliente . get ( f \"http://localhost:8000/catalogs/ { codigo } \" ) resposta . raise_for_status () print ( resposta . json ()) except httpx . HTTPStatusError as e : print ( f \"Erro ao recuperar produto de c\u00f3digo { codigo } : { e } \" ) async def main (): codigo_produtos = [ \"155568600\" , \"jj2a97g940\" , \"cb9a1801k9\" , \"224722100\" , \"702915400\" ] * 20 await asyncio . gather ( * ( recupera_produto ( codigo ) for codigo in codigo_produtos ), ) asyncio . run ( main ()) Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Este c\u00f3digo simula o que chamamos de estado de circuito fechado, as chamadas a api externa est\u00e3o sendo feitas e respondendo normalmente. Agora vamos introduzir um pouco de caos e ver o que acontece. Se estiver acompanhando o tutorial posteriormente, modifique a vari\u00e1vel de ambiente FAIL_RATE para 70 (valor expresso em porcentagem) e execute o c\u00f3digo da api simulada novamente. Rode novamente nosso c\u00f3digo (talvez seja necess\u00e1rio rodar algumas vezes) e veja o que acontece: python exemplo_circuito_breaker.py . Repare que agora um n\u00famero menor de pedidos s\u00e3o retornados com sucesso e falhas ocorrem de forma intermitente. Por algum motivo qualquer, algumas chamadas a api externa respondem com erro. Isto pode significar um problema de rede, uma falha na api externa, sobrecarga de requisi\u00e7\u00f5es na api externa, etc. Precisamos dar um tempo para ver se o sistema que estamos interagindo se recupera. Vamos introduzir ent\u00e3o um circuit breaker para modificarmos nosso sistema para um estado aberto. O luizalabs desenvolveu e mant\u00e9m como projeto open source o lasier , uma implementa\u00e7\u00e3o de circuit breaker com suporte a processos s\u00edncronos e ass\u00edncronos. Para n\u00e3o precisarmos adicionar maior complexidade ao exemplo utilizaremos um cache em mem\u00f3ria para guardar as informa\u00e7\u00f5es do nosso circuito (como n\u00famero de requisi\u00e7\u00f5es que falharam). Esse cache em mem\u00f3ria ser\u00e1 feito utilizando a biblioteca aiocache . Primeiro passo \u00e9 instalar as duas bibliotecas que ser\u00e3o necess\u00e1rias: Lasier: poetry add lasier Aiocache: poetry add aiocache Pr\u00f3ximo passo \u00e9 definir uma regra de quando vamos abrir o circuito: # ... from lasier.circuit_breaker.rules import PercentageFailuresRule rule = PercentageFailuresRule ( # Numero escolhido para facilitar # a visualiza\u00e7\u00e3o da solu\u00e7\u00e3o do problema max_failures_percentage = 30 , failure_cache_key = 'my_cb' , min_accepted_requests = 10 , request_cache_key = 'my_cb_request' ) # ... Essa configura\u00e7\u00e3o pode ser feita baseada tamb\u00e9m em n\u00famero de requisi\u00e7\u00f5es com falha . Al\u00e9m da regra de abertura do circuito, vamos definir um cache para armazenar as informa\u00e7\u00f5es do circuito e das requisi\u00e7\u00f5es que falharam. # ... from aiocache import Cache from lasier.adapters.caches import AiocacheAdapter # ... cache = AiocacheAdapter ( Cache ( Cache . MEMORY )) E agora vamos definir o circuito: import asyncio import httpx from aiocache import Cache from lasier.adapters.caches import AiocacheAdapter from lasier.circuit_breaker.asyncio import CircuitBreaker from lasier.circuit_breaker.rules import PercentageFailuresRule rule = PercentageFailuresRule ( # Numero escolhido para facilitar # a visualiza\u00e7\u00e3o da solu\u00e7\u00e3o do problema max_failures_percentage = 50 , failure_cache_key = \"my_cb\" , min_accepted_requests = 10 , request_cache_key = \"my_cb_request\" , ) cache = AiocacheAdapter ( Cache ( Cache . MEMORY )) class OpenCircuitError ( Exception ): pass def with_circuit_breaker ( func ): async def wrapper ( * args , ** kwargs ): try : async with CircuitBreaker ( rule , cache , failure_exception = OpenCircuitError , catch_exceptions = ( httpx . HTTPStatusError ,), ): return await func ( * args , ** kwargs ) except OpenCircuitError : # aqui poderia vir um tratamento para # quando o circuito est\u00e1 aberto como: # - enviar um email para o time # - reagendar a execu\u00e7\u00e3o da fun\u00e7\u00e3o # - recuperar o valor armazenado em cache print ( \"O circuito est\u00e1 aberto, alguma a\u00e7\u00e3o pode ser tomada.\" ) return wrapper @with_circuit_breaker async def recupera_produto ( codigo ): print ( f \"Recuperando produto de c\u00f3digo { codigo } \" ) async with httpx . AsyncClient () as cliente : resposta = await cliente . get ( f \"http://localhost:8000/catalogs/ { codigo } \" ) resposta . raise_for_status () print ( resposta . json ()) async def main (): codigo_produtos = [ \"155568600\" , \"jj2a97g940\" , \"cb9a1801k9\" , \"224722100\" , \"702915400\" ] * 20 await asyncio . gather ( * ( recupera_produto ( codigo ) for codigo in codigo_produtos ), ) asyncio . run ( main ()) Eu decidi criar um decorador para introduzir o circuit breaker. Ao perceber que o circuito est\u00e1 aberto, ele n\u00e3o executa a fun\u00e7\u00e3o, mas sim retorna um erro alertando sobre a abertura do circuito e uma a\u00e7\u00e3o pode ser tomada. \ud83d\udc81 Voc\u00ea deve estar se perguntando: \"E como funciona o estado semi aberto?\". Infelizmente isto ainda n\u00e3o foi implementado e por padr\u00e3o o circuito ser\u00e1 fechado em 60 segundos, ou outro valor configurado. Mas como \u00e9 um projeto de c\u00f3digo aberto, convido voc\u00eas a contribuirem e implementarem esta funcionalidade. \u2328\ufe0f Modificando nossa API Que tal adicionar circuit breaker em nosso sistema? \ud83d\udde3\ufe0f Quais seriam os pontos onde dever\u00edamos adicionar o circuit breaker? Em caso de falha o que faremos, retornaremos o valor em cache? Vamos adicionar algum recurso para isto como o Redis ? Ser\u00e1 que esta t\u00e9cnica \u00e9 mesmo necess\u00e1ria no nosso projeto? Reflita sobre estes questionamentos. Estas discuss\u00f5es s\u00e3o importantes e todas elas t\u00eam um \"trade off\", ou seja, podem ter algum custo. \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Caso decida modificar o seu c\u00f3digo para utilizar circuit breaker, como estamos adicionando novas bibliotecas ao nosso projeto e possivelmente mais c\u00f3digo tamb\u00e9m, vamos salvar a vers\u00e3o atual do c\u00f3digo. Adicione os arquivos que foram modificados com o comando git add e em seguida consolide a nova vers\u00e3o com o comando git commit -m \"Adicionando circuit breaker\" . N\u00e3o esque\u00e7a de enviar as altera\u00e7\u00f5es para o servidor remoto com o comando git push . Nesse ponto temos uma API que melhoramos o tempo de resposta e aumentamos a robustez. S\u00f3 isto \u00e9 suficiente? Na verdade temos v\u00e1rias outras t\u00e9cnicas que podemos usar para melhorar a nossa API. \ud83d\ude0a Olha tudo que fizemos at\u00e9 agora!\ud83c\udf88 Vamos continuar? \ud83d\udc02 Uma api robusta deve estar preparada para lidar com falhas.","title":"\ud83d\udd0c Circuit breaker"},{"location":"breaker/#circuit-breaker","text":"","title":"\ud83d\udd0c Circuit breaker"},{"location":"breaker/#o-problema","text":"Sistemas falham! E devemos estar preparados pra quando isto ocorrer. Se tudo foi implementado at\u00e9 o momento (incluindo os desafios), n\u00f3s temos integra\u00e7\u00f5es com dois sistemas distintos. E se um deles falhar? ou ambos? Vamos parar todo o nosso sistema por conta disto? E como saber se n\u00e3o \u00e9 apenas uma instabilidade? E se \u00e9 uma falha de rede? Voc\u00ea talvez j\u00e1 tenha ouvido falar em retentativas em cen\u00e1rios de integra\u00e7\u00e3o, mas essas retentativas podem degradar ainda mais o sistema ao qual estamos integrando. \ud83d\ude40 E agora? O que podemos fazer? E se pux\u00e1ssemos o plug que liga nosso sistema ao sistema externo temporariamente? O que vamos falar aqui se aplica a integra\u00e7\u00f5es com sistemas de terceiros ou sistemas distribu\u00eddos internos.","title":"\ud83d\udd25 O problema"},{"location":"breaker/#circuit-breaker_1","text":"A tradu\u00e7\u00e3o seria, \"disjuntor\", e seu papel na eletr\u00f4nica \u00e9 abrir o circuito que apresenta falha evitando uma sobrecarga de seus componentes. Esse termo tamb\u00e9m \u00e9 utilizado na bolsa de valores para quando h\u00e1 uma grande instabilidade (uma forte queda por exemplo), assim a bolsa de valores interrompe as negocia\u00e7\u00f5es temporariamente, evitando maiores perdas nesses momentos. Notaram uma semelhan\u00e7a na utiliza\u00e7\u00e3o do conceito? Temos uma falha e uma \"abertura\" do circuito para evitar maiores danos. Assim funciona o circuit breaker na computa\u00e7\u00e3o. Quando falamos em abrir um circuito, estamos falando na verdade em interromper a comunica\u00e7\u00e3o entre sistemas (temporariamente). Nygard em seu livro Release It explica bem o circuit breaker. Quote [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system. Nosso sistema tem os seguintes estados: Estado fechado: \u00e9 o estado onde tudo est\u00e1 funcionando normalmente e as requisi\u00e7\u00f5es ser\u00e3o feitas normalmente. Quando alguma condi\u00e7\u00e3o de falha \u00e9 detectada, o circuito \u00e9 aberto. Estado aberto: \u00e9 o estado onde o circuito est\u00e1 aberto e as requisi\u00e7\u00f5es n\u00e3o ser\u00e3o executadas. Um erro ser\u00e1 retornado ou uma informa\u00e7\u00e3o presente em cache. Estado semi aberto: \u00e9 o estado posterior ao estado aberto. Um teste \u00e9 feito para verificar a condi\u00e7\u00e3o atual do circuito, se uma falha ocorrer, o estado ser\u00e1 alternado para aberto novamente, mas se for bem-sucedido, ele volta para o estado fechado.","title":"\ud83d\udd0c Circuit breaker"},{"location":"breaker/#demonstracao-e-solucao","text":"Vamos fazer uma simula\u00e7\u00e3o utilizando c\u00f3digo para visualisar melhor este cen\u00e1rio. Crie um arquivo de exemplo como visto abaixo e execute-o para ver na pr\u00e1tica o que estamos falando. Para executa-lo utilize: python exemplo_circuito_breaker.py exemplo_circuito_breaker.py import asyncio import httpx async def recupera_produto ( codigo ): print ( f \"Recuperando produto de c\u00f3digo { codigo } \" ) try : async with httpx . AsyncClient () as cliente : resposta = await cliente . get ( f \"http://localhost:8000/catalogs/ { codigo } \" ) resposta . raise_for_status () print ( resposta . json ()) except httpx . HTTPStatusError as e : print ( f \"Erro ao recuperar produto de c\u00f3digo { codigo } : { e } \" ) async def main (): codigo_produtos = [ \"155568600\" , \"jj2a97g940\" , \"cb9a1801k9\" , \"224722100\" , \"702915400\" ] * 20 await asyncio . gather ( * ( recupera_produto ( codigo ) for codigo in codigo_produtos ), ) asyncio . run ( main ()) Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Este c\u00f3digo simula o que chamamos de estado de circuito fechado, as chamadas a api externa est\u00e3o sendo feitas e respondendo normalmente. Agora vamos introduzir um pouco de caos e ver o que acontece. Se estiver acompanhando o tutorial posteriormente, modifique a vari\u00e1vel de ambiente FAIL_RATE para 70 (valor expresso em porcentagem) e execute o c\u00f3digo da api simulada novamente. Rode novamente nosso c\u00f3digo (talvez seja necess\u00e1rio rodar algumas vezes) e veja o que acontece: python exemplo_circuito_breaker.py . Repare que agora um n\u00famero menor de pedidos s\u00e3o retornados com sucesso e falhas ocorrem de forma intermitente. Por algum motivo qualquer, algumas chamadas a api externa respondem com erro. Isto pode significar um problema de rede, uma falha na api externa, sobrecarga de requisi\u00e7\u00f5es na api externa, etc. Precisamos dar um tempo para ver se o sistema que estamos interagindo se recupera. Vamos introduzir ent\u00e3o um circuit breaker para modificarmos nosso sistema para um estado aberto. O luizalabs desenvolveu e mant\u00e9m como projeto open source o lasier , uma implementa\u00e7\u00e3o de circuit breaker com suporte a processos s\u00edncronos e ass\u00edncronos. Para n\u00e3o precisarmos adicionar maior complexidade ao exemplo utilizaremos um cache em mem\u00f3ria para guardar as informa\u00e7\u00f5es do nosso circuito (como n\u00famero de requisi\u00e7\u00f5es que falharam). Esse cache em mem\u00f3ria ser\u00e1 feito utilizando a biblioteca aiocache . Primeiro passo \u00e9 instalar as duas bibliotecas que ser\u00e3o necess\u00e1rias: Lasier: poetry add lasier Aiocache: poetry add aiocache Pr\u00f3ximo passo \u00e9 definir uma regra de quando vamos abrir o circuito: # ... from lasier.circuit_breaker.rules import PercentageFailuresRule rule = PercentageFailuresRule ( # Numero escolhido para facilitar # a visualiza\u00e7\u00e3o da solu\u00e7\u00e3o do problema max_failures_percentage = 30 , failure_cache_key = 'my_cb' , min_accepted_requests = 10 , request_cache_key = 'my_cb_request' ) # ... Essa configura\u00e7\u00e3o pode ser feita baseada tamb\u00e9m em n\u00famero de requisi\u00e7\u00f5es com falha . Al\u00e9m da regra de abertura do circuito, vamos definir um cache para armazenar as informa\u00e7\u00f5es do circuito e das requisi\u00e7\u00f5es que falharam. # ... from aiocache import Cache from lasier.adapters.caches import AiocacheAdapter # ... cache = AiocacheAdapter ( Cache ( Cache . MEMORY )) E agora vamos definir o circuito: import asyncio import httpx from aiocache import Cache from lasier.adapters.caches import AiocacheAdapter from lasier.circuit_breaker.asyncio import CircuitBreaker from lasier.circuit_breaker.rules import PercentageFailuresRule rule = PercentageFailuresRule ( # Numero escolhido para facilitar # a visualiza\u00e7\u00e3o da solu\u00e7\u00e3o do problema max_failures_percentage = 50 , failure_cache_key = \"my_cb\" , min_accepted_requests = 10 , request_cache_key = \"my_cb_request\" , ) cache = AiocacheAdapter ( Cache ( Cache . MEMORY )) class OpenCircuitError ( Exception ): pass def with_circuit_breaker ( func ): async def wrapper ( * args , ** kwargs ): try : async with CircuitBreaker ( rule , cache , failure_exception = OpenCircuitError , catch_exceptions = ( httpx . HTTPStatusError ,), ): return await func ( * args , ** kwargs ) except OpenCircuitError : # aqui poderia vir um tratamento para # quando o circuito est\u00e1 aberto como: # - enviar um email para o time # - reagendar a execu\u00e7\u00e3o da fun\u00e7\u00e3o # - recuperar o valor armazenado em cache print ( \"O circuito est\u00e1 aberto, alguma a\u00e7\u00e3o pode ser tomada.\" ) return wrapper @with_circuit_breaker async def recupera_produto ( codigo ): print ( f \"Recuperando produto de c\u00f3digo { codigo } \" ) async with httpx . AsyncClient () as cliente : resposta = await cliente . get ( f \"http://localhost:8000/catalogs/ { codigo } \" ) resposta . raise_for_status () print ( resposta . json ()) async def main (): codigo_produtos = [ \"155568600\" , \"jj2a97g940\" , \"cb9a1801k9\" , \"224722100\" , \"702915400\" ] * 20 await asyncio . gather ( * ( recupera_produto ( codigo ) for codigo in codigo_produtos ), ) asyncio . run ( main ()) Eu decidi criar um decorador para introduzir o circuit breaker. Ao perceber que o circuito est\u00e1 aberto, ele n\u00e3o executa a fun\u00e7\u00e3o, mas sim retorna um erro alertando sobre a abertura do circuito e uma a\u00e7\u00e3o pode ser tomada. \ud83d\udc81 Voc\u00ea deve estar se perguntando: \"E como funciona o estado semi aberto?\". Infelizmente isto ainda n\u00e3o foi implementado e por padr\u00e3o o circuito ser\u00e1 fechado em 60 segundos, ou outro valor configurado. Mas como \u00e9 um projeto de c\u00f3digo aberto, convido voc\u00eas a contribuirem e implementarem esta funcionalidade.","title":"\ud83e\uddd1\u200d\ud83c\udfeb Demonstra\u00e7\u00e3o e Solu\u00e7\u00e3o"},{"location":"breaker/#modificando-nossa-api","text":"Que tal adicionar circuit breaker em nosso sistema? \ud83d\udde3\ufe0f Quais seriam os pontos onde dever\u00edamos adicionar o circuit breaker? Em caso de falha o que faremos, retornaremos o valor em cache? Vamos adicionar algum recurso para isto como o Redis ? Ser\u00e1 que esta t\u00e9cnica \u00e9 mesmo necess\u00e1ria no nosso projeto? Reflita sobre estes questionamentos. Estas discuss\u00f5es s\u00e3o importantes e todas elas t\u00eam um \"trade off\", ou seja, podem ter algum custo.","title":"\u2328\ufe0f Modificando nossa API"},{"location":"breaker/#salvando-a-versao-atual-do-codigo","text":"Caso decida modificar o seu c\u00f3digo para utilizar circuit breaker, como estamos adicionando novas bibliotecas ao nosso projeto e possivelmente mais c\u00f3digo tamb\u00e9m, vamos salvar a vers\u00e3o atual do c\u00f3digo. Adicione os arquivos que foram modificados com o comando git add e em seguida consolide a nova vers\u00e3o com o comando git commit -m \"Adicionando circuit breaker\" . N\u00e3o esque\u00e7a de enviar as altera\u00e7\u00f5es para o servidor remoto com o comando git push . Nesse ponto temos uma API que melhoramos o tempo de resposta e aumentamos a robustez. S\u00f3 isto \u00e9 suficiente? Na verdade temos v\u00e1rias outras t\u00e9cnicas que podemos usar para melhorar a nossa API. \ud83d\ude0a Olha tudo que fizemos at\u00e9 agora!\ud83c\udf88 Vamos continuar? \ud83d\udc02 Uma api robusta deve estar preparada para lidar com falhas.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"continua/","text":"\u2714\ufe0f Integra\u00e7\u00e3o cont\u00ednua Conceito O desenvolvedor integra o c\u00f3digo alterado e/ou desenvolvido ao projeto principal na mesma frequ\u00eancia com que as funcionalidades s\u00e3o desenvolvidas, sendo feito muitas vezes. Todo o nosso projeto ser\u00e1 constru\u00eddo utilizando testes automatizados, e sempre rodaremos os testes localmente. Mas como garantir que minha altera\u00e7\u00e3o n\u00e3o impacta com o restante do projeto, ter isto de forma simples e automatizada? Como garantir que a qualidade do c\u00f3digo foi mantida? Utilizaremos o servi\u00e7o Github Actions para checar que nosso c\u00f3digo n\u00e3o quebra a \"build\", ou seja, quando integrado o novo c\u00f3digo ao sistema, todo o sistema continua funcional. Basicamente, a grande vantagem da integra\u00e7\u00e3o cont\u00ednua est\u00e1 no feedback instant\u00e2neo. Isso funciona da seguinte forma: a cada commit no reposit\u00f3rio, o build \u00e9 feito automaticamente, com todos os testes sendo executados de forma autom\u00e1tica e falhas sendo detectadas. Se algum commit n\u00e3o compilar ou quebrar qualquer um dos testes, a equipe toma conhecimento instant\u00e2neamente (atrav\u00e9s de email, por exemplo, indicando as falhas e o commit causador das mesmas). A equipe pode ent\u00e3o corrigir o problema o mais r\u00e1pido poss\u00edvel, o que \u00e9 fundamental para n\u00e3o introduzir erros ao criar novas funcionalidades, refatorar, etc. Integra\u00e7\u00e3o cont\u00ednua \u00e9 mais uma forma de trazer seguran\u00e7a em rela\u00e7\u00e3o a mudan\u00e7as: voc\u00ea pode fazer modifica\u00e7\u00f5es sem medo, pois ser\u00e1 avisado caso algo saia do esperado. Ferramentas Vamos instalar algumas ferramentas para nos ajudarem a terem um c\u00f3digo bem organizado e testado. \ud83d\udd20 isort O que \u00e9? isort \u00e9 uma ferramenta que ordena de forma alfab\u00e9tica as importa\u00e7\u00f5es, separando as bilbiotecas que s\u00e3o padr\u00f5es da linguagem, as externas ao sistema e as nativas do pr\u00f3prio sistema. Para que serve? O isort ir\u00e1 modificar o seu c\u00f3digo ordenando as importa\u00e7\u00f5es alfab\u00e9ticamente. Dessa forma, o bloco de importa\u00e7\u00f5es fica organizado e padronizado no projeto. Como instalar Execute o comando abaixo: poetry add isort --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software. Configura\u00e7\u00e3o Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.isort] profile = \"black\" line_length = 79 Como executar poetry run isort . Assim evitamos um conflito com a ferramenta black e flake8 . \u2728 Black O que \u00e9? Black \u00e9 o formatador de c\u00f3digo Python intransigente. Ao us\u00e1-lo, voc\u00ea concorda em ceder o controle sobre as min\u00facias da formata\u00e7\u00e3o manual. Em troca, o black d\u00e1 a voc\u00ea velocidade, determinismo e liberdade do irritante pycodestyle sobre formata\u00e7\u00e3o. Voc\u00ea economizar\u00e1 tempo e energia mental para assuntos mais importantes. Para que serve? O black \u00e9 um formatador autom\u00e1tico de c\u00f3digo, ele ir\u00e1 modificar o seu c\u00f3digo seguindo o guia de estilo do Python. Iremos configur\u00e1-lo junto ao nosso editor para que a formata\u00e7\u00e3o seja feita atrav\u00e9s de um atalho do teclado como shift + ctrl + i. Como instalar Execute o comando abaixo: poetry add black --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software. Configura\u00e7\u00e3o Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.black] line-length = 79 Como executar poetry run black . Assim evitamos um conflito com a ferramenta flake8 . \ud83c\udfa8 Flake8 O que \u00e9? Flake8 \u00e9 um programa de linha de comando que verifica seu c\u00f3digo e busca por erros ou formata\u00e7\u00f5es que n\u00e3o seguem o guia de estilo padr\u00e3o do python, conhecido como PEP-8 . Al\u00e9m disso tamb\u00e9m verifica a complexidade ciclom\u00e1tica do seu c\u00f3digo. Para que serve? \u00c9 muito comum cometermos alguns erros de sintaxe, principalmente quando ainda estamos nos familiarizando com uma linguagem nova. Assim como durante o nosso dia a dia podemos esquecer algum c\u00f3digo n\u00e3o utilizado. Esta ferramenta vai analisar o seu c\u00f3digo e procurar poss\u00edveis erros, evitando assim que s\u00f3 ocorram no momento em que o c\u00f3digo for executado. Esta ferramenta tamb\u00e9m aponta poss\u00edveis linhas que n\u00e3o est\u00e3o seguindo o estilo de c\u00f3digo definido para a linguagem python. Outra coisa bem comum quando estamos escrevendo c\u00f3digo \u00e9 que uma parte dele come\u00e7a a se tornar t\u00e3o complexa que h\u00e1 n caminhos por onde seu algoritmo pode seguir. Normalmente isto indica que devemos modificar o c\u00f3digo para torn\u00e1-lo mais simples e leg\u00edvel. O Flake8 ir\u00e1 apontar qual parte do seu c\u00f3digo est\u00e1 complexa e que deve ser modificada. Esta ferramenta ser\u00e1 integrada ao editor, dessa maneira, ao salvar o arquivo, teremos os erros encontrados apontados diretamente no mesmo. Como instalar Execute o comando abaixo: poetry add flake8 --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software. Como executar poetry run flake8 . Info Pode ser necess\u00e1rio a interven\u00e7\u00f5es manuais para que o c\u00f3digo seja corrigido. \ud83d\udd75\ufe0f pre-commit (Men\u00e7\u00e3o honrosa \ud83c\udfc5) Existem ferramentas que podem executar algum comando antes de um commit, com o objetivo de identificar poss\u00edveis problemas no seu programa antes do envio do c\u00f3digo para o reposit\u00f3rio remoto. Os comandos listados acima s\u00e3o bons exemplos de execu\u00e7\u00f5es que podem ocorrer neste momento. Uma das ferramentas que prov\u00ea essa funcionalidade \u00e9 o pre-commit. Para saber mais, clique aqui . \ud83d\udc31 Configurando o Github Actions Crie a pasta .github/workflows dentro do seu reposit\u00f3rio. Essa \u00e9 a pasta padr\u00e3o para as configura\u00e7\u00f5es do Github Actions. Dentro da pasta crie um arquivo chamado main.yml . Esse arquivo ser\u00e1 utilizado para determinar quais passos ser\u00e3o executados na integra\u00e7\u00e3o. O arquivo deve possuir o seguinte conte\u00fado: name: main on: [push, pull_request] jobs: linter-and-tests: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python uses: actions/setup-python@v2 with: python-version: 3.9 - name: Set up poetry uses: abatilo/actions-poetry@v2.1.0 with: poetry-version: 1.1.5 - name: Configure poetry shell: bash run: python -m poetry config virtualenvs.in-project true - name: Set up cache uses: actions/cache@v2 id: cache with: path: .venv key: venv-${{ hashFiles('**/poetry.lock') }} - name: Ensure cache is healthy if: steps.cache.outputs.cache-hit == 'true' shell: bash run: timeout 10s python -m poetry run pip --version || rm -rf .venv - name: Install dependencies shell: bash run: python -m poetry install - name: Run isort shell: bash run: python -m poetry run python -m isort --check . - name: Run black shell: bash run: python -m poetry run python -m black --check . - name: Run flake8 shell: bash run: python -m poetry run python -m flake8 . --exclude=.venv - name: Run tests shell: bash run: python -m poetry run python -m pytest . Atrav\u00e9s do arquivo de configura\u00e7\u00e3o, n\u00f3s definimos que alguns passos ser\u00e3o executados toda vez que houver um push ou a abertura de um pull request no reposit\u00f3rio. Os passos executados ser\u00e3o os seguintes: 1 - Instalar todas as depend\u00eancias necess\u00e1rias. 2 - Executar o isort. 3 - Executar o black. 4 - Executar o flake8. 4 - Executar os testes. \ud83c\udf89 Pronto, a partir de agora, o Github Actions ir\u00e1 rodar todos as valida\u00e7\u00f5es e testes do seu projeto de forma automatizada e indicar\u00e1 se a constru\u00e7\u00e3o do mesmo est\u00e1 com problemas. \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) pyproject.toml poetry.lock Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .github/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos uma pasta n\u00e3o rastreada, precisamos avisar ao controle de vers\u00e3o que monitore a pasta e seu conte\u00fado. git add .github/ Vamos adicionar tamb\u00e9m as novas depend\u00eancias instaladas. git add pyproject.toml poetry.lock Warning Adicione tamb\u00e9m os arquivos que possivelmente foram modificados por nossas ferramentas de qualidade. \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona integra\u00e7\u00e3o cont\u00ednua\" \ud83d\udc31 Por fim, envie ao github a vers\u00e3o atualizada do projeto. git push \u2705 Pronto, agora o seu projeto est\u00e1 integrado com o Github Actions. \ud83c\udf89 Cumprimos mais um requisito: O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; Confira na aba actions do seu reposit\u00f3rio. \ud83d\udc02 Uma api robusta possui evolu\u00e7\u00e3o cont\u00ednua garantindo qualidade a cada vers\u00e3o.","title":"\u2714\ufe0f Integra\u00e7\u00e3o cont\u00ednua"},{"location":"continua/#integracao-continua","text":"","title":"\u2714\ufe0f Integra\u00e7\u00e3o cont\u00ednua"},{"location":"continua/#conceito","text":"O desenvolvedor integra o c\u00f3digo alterado e/ou desenvolvido ao projeto principal na mesma frequ\u00eancia com que as funcionalidades s\u00e3o desenvolvidas, sendo feito muitas vezes. Todo o nosso projeto ser\u00e1 constru\u00eddo utilizando testes automatizados, e sempre rodaremos os testes localmente. Mas como garantir que minha altera\u00e7\u00e3o n\u00e3o impacta com o restante do projeto, ter isto de forma simples e automatizada? Como garantir que a qualidade do c\u00f3digo foi mantida? Utilizaremos o servi\u00e7o Github Actions para checar que nosso c\u00f3digo n\u00e3o quebra a \"build\", ou seja, quando integrado o novo c\u00f3digo ao sistema, todo o sistema continua funcional. Basicamente, a grande vantagem da integra\u00e7\u00e3o cont\u00ednua est\u00e1 no feedback instant\u00e2neo. Isso funciona da seguinte forma: a cada commit no reposit\u00f3rio, o build \u00e9 feito automaticamente, com todos os testes sendo executados de forma autom\u00e1tica e falhas sendo detectadas. Se algum commit n\u00e3o compilar ou quebrar qualquer um dos testes, a equipe toma conhecimento instant\u00e2neamente (atrav\u00e9s de email, por exemplo, indicando as falhas e o commit causador das mesmas). A equipe pode ent\u00e3o corrigir o problema o mais r\u00e1pido poss\u00edvel, o que \u00e9 fundamental para n\u00e3o introduzir erros ao criar novas funcionalidades, refatorar, etc. Integra\u00e7\u00e3o cont\u00ednua \u00e9 mais uma forma de trazer seguran\u00e7a em rela\u00e7\u00e3o a mudan\u00e7as: voc\u00ea pode fazer modifica\u00e7\u00f5es sem medo, pois ser\u00e1 avisado caso algo saia do esperado.","title":"Conceito"},{"location":"continua/#ferramentas","text":"Vamos instalar algumas ferramentas para nos ajudarem a terem um c\u00f3digo bem organizado e testado.","title":"Ferramentas"},{"location":"continua/#isort","text":"","title":"\ud83d\udd20 isort"},{"location":"continua/#o-que-e","text":"isort \u00e9 uma ferramenta que ordena de forma alfab\u00e9tica as importa\u00e7\u00f5es, separando as bilbiotecas que s\u00e3o padr\u00f5es da linguagem, as externas ao sistema e as nativas do pr\u00f3prio sistema.","title":"O que \u00e9?"},{"location":"continua/#para-que-serve","text":"O isort ir\u00e1 modificar o seu c\u00f3digo ordenando as importa\u00e7\u00f5es alfab\u00e9ticamente. Dessa forma, o bloco de importa\u00e7\u00f5es fica organizado e padronizado no projeto.","title":"Para que serve?"},{"location":"continua/#como-instalar","text":"Execute o comando abaixo: poetry add isort --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software.","title":"Como instalar"},{"location":"continua/#configuracao","text":"Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.isort] profile = \"black\" line_length = 79","title":"Configura\u00e7\u00e3o"},{"location":"continua/#como-executar","text":"poetry run isort . Assim evitamos um conflito com a ferramenta black e flake8 .","title":"Como executar"},{"location":"continua/#black","text":"","title":"\u2728 Black"},{"location":"continua/#o-que-e_1","text":"Black \u00e9 o formatador de c\u00f3digo Python intransigente. Ao us\u00e1-lo, voc\u00ea concorda em ceder o controle sobre as min\u00facias da formata\u00e7\u00e3o manual. Em troca, o black d\u00e1 a voc\u00ea velocidade, determinismo e liberdade do irritante pycodestyle sobre formata\u00e7\u00e3o. Voc\u00ea economizar\u00e1 tempo e energia mental para assuntos mais importantes.","title":"O que \u00e9?"},{"location":"continua/#para-que-serve_1","text":"O black \u00e9 um formatador autom\u00e1tico de c\u00f3digo, ele ir\u00e1 modificar o seu c\u00f3digo seguindo o guia de estilo do Python. Iremos configur\u00e1-lo junto ao nosso editor para que a formata\u00e7\u00e3o seja feita atrav\u00e9s de um atalho do teclado como shift + ctrl + i.","title":"Para que serve?"},{"location":"continua/#como-instalar_1","text":"Execute o comando abaixo: poetry add black --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software.","title":"Como instalar"},{"location":"continua/#configuracao_1","text":"Precisamos adicionar no arquivo pyproject.toml a seguinte configura\u00e7\u00e3o [tool.black] line-length = 79","title":"Configura\u00e7\u00e3o"},{"location":"continua/#como-executar_1","text":"poetry run black . Assim evitamos um conflito com a ferramenta flake8 .","title":"Como executar"},{"location":"continua/#flake8","text":"","title":"\ud83c\udfa8 Flake8"},{"location":"continua/#o-que-e_2","text":"Flake8 \u00e9 um programa de linha de comando que verifica seu c\u00f3digo e busca por erros ou formata\u00e7\u00f5es que n\u00e3o seguem o guia de estilo padr\u00e3o do python, conhecido como PEP-8 . Al\u00e9m disso tamb\u00e9m verifica a complexidade ciclom\u00e1tica do seu c\u00f3digo.","title":"O que \u00e9?"},{"location":"continua/#para-que-serve_2","text":"\u00c9 muito comum cometermos alguns erros de sintaxe, principalmente quando ainda estamos nos familiarizando com uma linguagem nova. Assim como durante o nosso dia a dia podemos esquecer algum c\u00f3digo n\u00e3o utilizado. Esta ferramenta vai analisar o seu c\u00f3digo e procurar poss\u00edveis erros, evitando assim que s\u00f3 ocorram no momento em que o c\u00f3digo for executado. Esta ferramenta tamb\u00e9m aponta poss\u00edveis linhas que n\u00e3o est\u00e3o seguindo o estilo de c\u00f3digo definido para a linguagem python. Outra coisa bem comum quando estamos escrevendo c\u00f3digo \u00e9 que uma parte dele come\u00e7a a se tornar t\u00e3o complexa que h\u00e1 n caminhos por onde seu algoritmo pode seguir. Normalmente isto indica que devemos modificar o c\u00f3digo para torn\u00e1-lo mais simples e leg\u00edvel. O Flake8 ir\u00e1 apontar qual parte do seu c\u00f3digo est\u00e1 complexa e que deve ser modificada. Esta ferramenta ser\u00e1 integrada ao editor, dessa maneira, ao salvar o arquivo, teremos os erros encontrados apontados diretamente no mesmo.","title":"Para que serve?"},{"location":"continua/#como-instalar_2","text":"Execute o comando abaixo: poetry add flake8 --dev Info Utilizamos a op\u00e7\u00e3o --dev pois \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software.","title":"Como instalar"},{"location":"continua/#como-executar_2","text":"poetry run flake8 . Info Pode ser necess\u00e1rio a interven\u00e7\u00f5es manuais para que o c\u00f3digo seja corrigido.","title":"Como executar"},{"location":"continua/#pre-commit-mencao-honrosa","text":"Existem ferramentas que podem executar algum comando antes de um commit, com o objetivo de identificar poss\u00edveis problemas no seu programa antes do envio do c\u00f3digo para o reposit\u00f3rio remoto. Os comandos listados acima s\u00e3o bons exemplos de execu\u00e7\u00f5es que podem ocorrer neste momento. Uma das ferramentas que prov\u00ea essa funcionalidade \u00e9 o pre-commit. Para saber mais, clique aqui .","title":"\ud83d\udd75\ufe0f pre-commit (Men\u00e7\u00e3o honrosa \ud83c\udfc5)"},{"location":"continua/#configurando-o-github-actions","text":"Crie a pasta .github/workflows dentro do seu reposit\u00f3rio. Essa \u00e9 a pasta padr\u00e3o para as configura\u00e7\u00f5es do Github Actions. Dentro da pasta crie um arquivo chamado main.yml . Esse arquivo ser\u00e1 utilizado para determinar quais passos ser\u00e3o executados na integra\u00e7\u00e3o. O arquivo deve possuir o seguinte conte\u00fado: name: main on: [push, pull_request] jobs: linter-and-tests: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python uses: actions/setup-python@v2 with: python-version: 3.9 - name: Set up poetry uses: abatilo/actions-poetry@v2.1.0 with: poetry-version: 1.1.5 - name: Configure poetry shell: bash run: python -m poetry config virtualenvs.in-project true - name: Set up cache uses: actions/cache@v2 id: cache with: path: .venv key: venv-${{ hashFiles('**/poetry.lock') }} - name: Ensure cache is healthy if: steps.cache.outputs.cache-hit == 'true' shell: bash run: timeout 10s python -m poetry run pip --version || rm -rf .venv - name: Install dependencies shell: bash run: python -m poetry install - name: Run isort shell: bash run: python -m poetry run python -m isort --check . - name: Run black shell: bash run: python -m poetry run python -m black --check . - name: Run flake8 shell: bash run: python -m poetry run python -m flake8 . --exclude=.venv - name: Run tests shell: bash run: python -m poetry run python -m pytest . Atrav\u00e9s do arquivo de configura\u00e7\u00e3o, n\u00f3s definimos que alguns passos ser\u00e3o executados toda vez que houver um push ou a abertura de um pull request no reposit\u00f3rio. Os passos executados ser\u00e3o os seguintes: 1 - Instalar todas as depend\u00eancias necess\u00e1rias. 2 - Executar o isort. 3 - Executar o black. 4 - Executar o flake8. 4 - Executar os testes. \ud83c\udf89 Pronto, a partir de agora, o Github Actions ir\u00e1 rodar todos as valida\u00e7\u00f5es e testes do seu projeto de forma automatizada e indicar\u00e1 se a constru\u00e7\u00e3o do mesmo est\u00e1 com problemas.","title":"\ud83d\udc31 Configurando o Github Actions"},{"location":"continua/#salvando-a-versao-atual-do-codigo","text":"Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) pyproject.toml poetry.lock Untracked files: ( use \"git add <file>...\" to include in what will be committed ) .github/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos uma pasta n\u00e3o rastreada, precisamos avisar ao controle de vers\u00e3o que monitore a pasta e seu conte\u00fado. git add .github/ Vamos adicionar tamb\u00e9m as novas depend\u00eancias instaladas. git add pyproject.toml poetry.lock Warning Adicione tamb\u00e9m os arquivos que possivelmente foram modificados por nossas ferramentas de qualidade. \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona integra\u00e7\u00e3o cont\u00ednua\" \ud83d\udc31 Por fim, envie ao github a vers\u00e3o atualizada do projeto. git push \u2705 Pronto, agora o seu projeto est\u00e1 integrado com o Github Actions. \ud83c\udf89 Cumprimos mais um requisito: O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; Confira na aba actions do seu reposit\u00f3rio. \ud83d\udc02 Uma api robusta possui evolu\u00e7\u00e3o cont\u00ednua garantindo qualidade a cada vers\u00e3o.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"desafios/","text":"\ud83c\udfc6 Desafios \u00c0 partir de agora, o seu desafio \u00e9 continuar escrevendo as funcionalidades que faltam, mas vou te dar umas dicas. Relembrando, ainda temos as seguintes tarefas a serem feitas. Deve apresentar uma interface que possa ser consumida tanto por um website, quanto por um aplicativo para dispositivos m\u00f3veis; Deve prover um endpoint que indique a sa\u00fade do sistema; Dado um pedido, retornar os seus itens; Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos; Dado um pedido (v\u00e1rios itens), enriquecer a informa\u00e7\u00e3o com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m a marca, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto. Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; O sistema deve apresentar testes. Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. Se n\u00e3o lembra os endpoints dispon\u00edveis, volte na p\u00e1gina onde exploramos a API. \ud83d\udcca Relat\u00f3rio Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos (em um cen\u00e1rio real este crit\u00e9rio seria outro como uma data). Para obter esta informa\u00e7\u00e3o precisamos de consultar a api de pedidos do Magalu . Verifique o endpoint que cont\u00e9m esta informa\u00e7\u00e3o e se atente \u00e0 pagina\u00e7\u00e3o do recurso, ou seja, a p\u00e1gina s\u00f3 contem 10 pedidos. Nosso endpoint ser\u00e1 /report/ e o seu formato de resposta ser\u00e1 um JSON. O c\u00f3digo de status ser\u00e1 200 OK . Vamos utilizar o mesmo X-Tenant-id que j\u00e1 utilizamos para acessar a API de pedidos. Este valor seria din\u00e2mico em uma aplica\u00e7\u00e3o real. [ { \"payment_method\" : \"magalu_card\" , \"total\" : 5 }, { \"payment_method\" : \"pix\" , \"total\" : 3 }, { \"payment_method\" : \"mastercard\" , \"total\" : 5 } ] \ud83c\udf81 O produto Dado uma lista de itens de um pedido, enriquecer com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m o nome, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto. Nosso endpoint ser\u00e1 /orders/enriched . Diferente do que vimos at\u00e9 agora ser\u00e1 uma chamada utilizando o verbo POST com o seguinte payload: { \"items\" : [ \"123456789\" , \"987654321\" , \"444455558\" ] } Cada valor contido no array items ser\u00e1 um c\u00f3digo que identifica um produto. O retorno deve ser um JSON com o seguinte formato: { \"items\" : { \"123456789\" : { \"name\" : \"Produto 1\" , \"description\" : \"Descri\u00e7\u00e3o do produto 1\" , \"gtin\" : \"7890000000000\" }, \"987654321\" : { \"name\" : \"Produto 2\" , \"description\" : \"Descri\u00e7\u00e3o do produto 2\" , \"gtin\" : \"7890000000001\" } }, \"missing\" : [ \"444455558\" ] } Caso algum produto n\u00e3o seja encontrado, deve ser adicionado a chave \"missing\" . \ud83c\udfc1 Concluindo (ou quase) Assim finalizamos a primeira parte do guia, espero que tenha curtido bastante esta jornada de aprendizado. Daqui pra frente vamos ver t\u00e9cnicas complementares para melhorar a qualidade e robustez do nosso sistema. Ainda temos v\u00e1rias coisas n\u00e3o abordadas neste guia que complementam nossa aplica\u00e7\u00e3o, mas que tornariam a did\u00e1tica pior ou seriam muito extensas. Recomendo que vejam at\u00e9 o final as refer\u00eancias e continuem se aperfei\u00e7oando. Caso tenham gostado, n\u00e3o deixe de estrelar o reposit\u00f3rio como forma de gratid\u00e3o. Isto motiva a escrever mais materiais interessantes como este em portugu\u00eas. \ud83d\udc02 Uma api robusta possui as funcionalidades esperadas.","title":"\ud83c\udfc6 Desafios"},{"location":"desafios/#desafios","text":"\u00c0 partir de agora, o seu desafio \u00e9 continuar escrevendo as funcionalidades que faltam, mas vou te dar umas dicas. Relembrando, ainda temos as seguintes tarefas a serem feitas. Deve apresentar uma interface que possa ser consumida tanto por um website, quanto por um aplicativo para dispositivos m\u00f3veis; Deve prover um endpoint que indique a sa\u00fade do sistema; Dado um pedido, retornar os seus itens; Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos; Dado um pedido (v\u00e1rios itens), enriquecer a informa\u00e7\u00e3o com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m a marca, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto. Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; O sistema deve apresentar testes. Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. Se n\u00e3o lembra os endpoints dispon\u00edveis, volte na p\u00e1gina onde exploramos a API.","title":"\ud83c\udfc6 Desafios"},{"location":"desafios/#relatorio","text":"Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos (em um cen\u00e1rio real este crit\u00e9rio seria outro como uma data). Para obter esta informa\u00e7\u00e3o precisamos de consultar a api de pedidos do Magalu . Verifique o endpoint que cont\u00e9m esta informa\u00e7\u00e3o e se atente \u00e0 pagina\u00e7\u00e3o do recurso, ou seja, a p\u00e1gina s\u00f3 contem 10 pedidos. Nosso endpoint ser\u00e1 /report/ e o seu formato de resposta ser\u00e1 um JSON. O c\u00f3digo de status ser\u00e1 200 OK . Vamos utilizar o mesmo X-Tenant-id que j\u00e1 utilizamos para acessar a API de pedidos. Este valor seria din\u00e2mico em uma aplica\u00e7\u00e3o real. [ { \"payment_method\" : \"magalu_card\" , \"total\" : 5 }, { \"payment_method\" : \"pix\" , \"total\" : 3 }, { \"payment_method\" : \"mastercard\" , \"total\" : 5 } ]","title":"\ud83d\udcca Relat\u00f3rio"},{"location":"desafios/#o-produto","text":"Dado uma lista de itens de um pedido, enriquecer com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m o nome, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto. Nosso endpoint ser\u00e1 /orders/enriched . Diferente do que vimos at\u00e9 agora ser\u00e1 uma chamada utilizando o verbo POST com o seguinte payload: { \"items\" : [ \"123456789\" , \"987654321\" , \"444455558\" ] } Cada valor contido no array items ser\u00e1 um c\u00f3digo que identifica um produto. O retorno deve ser um JSON com o seguinte formato: { \"items\" : { \"123456789\" : { \"name\" : \"Produto 1\" , \"description\" : \"Descri\u00e7\u00e3o do produto 1\" , \"gtin\" : \"7890000000000\" }, \"987654321\" : { \"name\" : \"Produto 2\" , \"description\" : \"Descri\u00e7\u00e3o do produto 2\" , \"gtin\" : \"7890000000001\" } }, \"missing\" : [ \"444455558\" ] } Caso algum produto n\u00e3o seja encontrado, deve ser adicionado a chave \"missing\" .","title":"\ud83c\udf81 O produto"},{"location":"desafios/#concluindo-ou-quase","text":"Assim finalizamos a primeira parte do guia, espero que tenha curtido bastante esta jornada de aprendizado. Daqui pra frente vamos ver t\u00e9cnicas complementares para melhorar a qualidade e robustez do nosso sistema. Ainda temos v\u00e1rias coisas n\u00e3o abordadas neste guia que complementam nossa aplica\u00e7\u00e3o, mas que tornariam a did\u00e1tica pior ou seriam muito extensas. Recomendo que vejam at\u00e9 o final as refer\u00eancias e continuem se aperfei\u00e7oando. Caso tenham gostado, n\u00e3o deixe de estrelar o reposit\u00f3rio como forma de gratid\u00e3o. Isto motiva a escrever mais materiais interessantes como este em portugu\u00eas. \ud83d\udc02 Uma api robusta possui as funcionalidades esperadas.","title":"\ud83c\udfc1 Concluindo (ou quase)"},{"location":"docs/","text":"\ud83d\udcdc Documenta\u00e7\u00e3o \ud83d\udcd6 Por que documentar? Temos nossa API funcionando, mas ainda n\u00e3o temos nenhuma documenta\u00e7\u00e3o. Como esperar a integra\u00e7\u00e3o de terceiros em nosso sistema? Seria t\u00e3o bom se pudesse transformar todo esse c\u00f3digo produzido at\u00e9 agora com as defini\u00e7\u00f5es de valores de entrada e sa\u00edda em um documento de forma que fosse mais f\u00e1cil de entender. Por sorte o FastAPI j\u00e1 tem um Swagger que pode ser usado para gerar uma documenta\u00e7\u00e3o. Mas onde est\u00e1 essa documenta\u00e7\u00e3o? Preciso dar algum comando especial? At\u00e9 agora est\u00e1vamos testando nossa aplica\u00e7\u00e3o manualmente utilizando a ferramenta httpie , mas que tal se tivessemos uma interface mais amig\u00e1vel para testar nossa aplica\u00e7\u00e3o? Se a sua aplica\u00e7\u00e3o n\u00e3o estiver no ar, suba-a atrav\u00e9s do comando: uvicorn --reload api_pedidos.api:app Agora acesse a URL http://localhost:8000/docs e veja a documenta\u00e7\u00e3o. Alem desta interface, temos tamb\u00e9m a gera\u00e7\u00e3o autom\u00e1tica de uma documenta\u00e7\u00e3o seguindo as especifica\u00e7\u00f5es da OpenAPI 3.0 . Voc\u00ea pode acessa-la atrav\u00e9s do endere\u00e7o http://localhost:8000/docs/openapi.json . Isto nos traz dois benef\u00edcios, agora possuimos uma documenta\u00e7\u00e3o interativa seguindo um padr\u00e3o consolidado no mercado, e tamb\u00e9m possuimos uma documenta\u00e7\u00e3o que pode ser usada para gerar automaticamente um cliente da API em diversas linguagens. Info Consulte https://swagger.io/tools/swagger-codegen/ para saber mais sobre o processo de gera\u00e7\u00e3o de clientes \u00e0 partir de uma documenta\u00e7\u00e3o. \ud83d\udcd4 Aprimorando nossa documenta\u00e7\u00e3o Navegando por nossa api percebemos que ambos os endpoints est\u00e3o agrupados em conjunto chamado default . Podemos melhorar isto agrupando os endpoints de recursos similares utilizando tags . Hoje nossa documenta\u00e7\u00e3o est\u00e1 assim: Modificando ambos os endpoints para serem agrupados por tags, ficamos assim: api_pedidos/api.py # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ]) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , tags = [ \"pedidos\" ]) # ... Uma outra melhoria que podemos fazer em nossa documenta\u00e7\u00e3o \u00e9 aprimorar a exibi\u00e7\u00e3o de cada um dos endpoints (hoje a descri\u00e7\u00e3o curta \u00e9 apenas o nome da fun\u00e7\u00e3o que utilizamos). Essa altera\u00e7\u00e3o ser\u00e1 feita no arquivo api_pedidos/api.py : api_pedidos/api.py # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" ) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , tags = [ \"pedidos\" ], summary = \"Itens de um pedido\" ) # ... Vamos adicionar tamb\u00e9m uma descri\u00e7\u00e3o mais detalhada para cada endpoint . # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" ) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" ) # ... Uma outra melhoria seria tornar expl\u00edcito o retorno dos endpoints desenvolvidos at\u00e9 agora. Come\u00e7ando pelo healthcheck : Antes da melhoria, a documenta\u00e7\u00e3o era assim: api_pedidos/esquema.py # ... class HealthCheckResponse ( BaseModel ): status : str api_pedidos/api.py from api_pedidos.esquema import HealthCheckResponse , Item # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" , response_model = HealthCheckResponse ) def healthcheck (): return HealthCheckResponse ( status = \"ok\" ) # ... Ap\u00f3s a melhoria, a documenta\u00e7\u00e3o fica assim: Vamos fazer um ajuste similar para o endpoint de pedidos : Antes da melhoria, a documenta\u00e7\u00e3o era assim: api_pedidos/api.py # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ]) # ... Warning Se estiver utilizando Python na em vers\u00f5es anteriores a 3.9, deve-se utilizar o tipo List[Item] para o retorno do endpoint. Depois da melhoria, a documenta\u00e7\u00e3o fica assim: Durante a implementa\u00e7\u00e3o n\u00f3s definimos alguns cen\u00e1rios poss\u00edveis como o pedido n\u00e3o existir, ou n\u00e3o conseguir se comunicar com a API externa. Mas estes retornos n\u00e3o est\u00e3o sinalizados na nossa documenta\u00e7\u00e3o. Vamos adicion\u00e1-los?! Primeira coisa, talvez seja interessante padronizarmos os retornos de erro da nossa api em um esquema. api_pedidos/esquema.py # ... class ErrorResponse ( BaseModel ): message : str Depois disso vamos adicionar o esquema de retorno de erro na documenta\u00e7\u00e3o: # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , responses = { HTTPStatus . NOT_FOUND . value : { \"description\" : \"Pedido n\u00e3o encontrado\" , \"model\" : ErrorResponse , }, HTTPStatus . BAD_GATEWAY . value : { \"description\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" , \"model\" : ErrorResponse , }}, summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ]) # ... \ud83d\udc81 Ainda temos outras customiza\u00e7\u00f5es na documenta\u00e7\u00e3o que podem ser interessantes como exemplos de entradas e sa\u00eddas. Para mais exemplos consulte: https://fastapi.tiangolo.com/advanced/additional-responses/ \ud83e\udd73 Agora nossa api est\u00e1 documentada! Ficou muito mais f\u00e1cil para algu\u00e9m que queira se integrar a sua API. Mas n\u00e3o se esque\u00e7a de manter a documenta\u00e7\u00e3o sempre atualizada! \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py modified: api_pedidos/esquema.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar as mudan\u00e7as nesta revis\u00e3o. git add api_pedidos/api.py api_pedidos/esquema.py \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Adiciona documenta\u00e7\u00e3o ao projeto\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Agora que temos uma api e documenta\u00e7\u00e3o, vamos dar um pr\u00f3ximo passo na qualidade e evolu\u00e7\u00e3o do nosso projeto. Cumprimos mais um requisito: Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; \ud83d\udc02 Uma api robusta possui boa documenta\u00e7\u00e3o facilitando assim uma integra\u00e7\u00e3o externa.","title":"\ud83d\udcdc Documenta\u00e7\u00e3o"},{"location":"docs/#documentacao","text":"","title":"\ud83d\udcdc Documenta\u00e7\u00e3o"},{"location":"docs/#por-que-documentar","text":"Temos nossa API funcionando, mas ainda n\u00e3o temos nenhuma documenta\u00e7\u00e3o. Como esperar a integra\u00e7\u00e3o de terceiros em nosso sistema? Seria t\u00e3o bom se pudesse transformar todo esse c\u00f3digo produzido at\u00e9 agora com as defini\u00e7\u00f5es de valores de entrada e sa\u00edda em um documento de forma que fosse mais f\u00e1cil de entender. Por sorte o FastAPI j\u00e1 tem um Swagger que pode ser usado para gerar uma documenta\u00e7\u00e3o. Mas onde est\u00e1 essa documenta\u00e7\u00e3o? Preciso dar algum comando especial? At\u00e9 agora est\u00e1vamos testando nossa aplica\u00e7\u00e3o manualmente utilizando a ferramenta httpie , mas que tal se tivessemos uma interface mais amig\u00e1vel para testar nossa aplica\u00e7\u00e3o? Se a sua aplica\u00e7\u00e3o n\u00e3o estiver no ar, suba-a atrav\u00e9s do comando: uvicorn --reload api_pedidos.api:app Agora acesse a URL http://localhost:8000/docs e veja a documenta\u00e7\u00e3o. Alem desta interface, temos tamb\u00e9m a gera\u00e7\u00e3o autom\u00e1tica de uma documenta\u00e7\u00e3o seguindo as especifica\u00e7\u00f5es da OpenAPI 3.0 . Voc\u00ea pode acessa-la atrav\u00e9s do endere\u00e7o http://localhost:8000/docs/openapi.json . Isto nos traz dois benef\u00edcios, agora possuimos uma documenta\u00e7\u00e3o interativa seguindo um padr\u00e3o consolidado no mercado, e tamb\u00e9m possuimos uma documenta\u00e7\u00e3o que pode ser usada para gerar automaticamente um cliente da API em diversas linguagens. Info Consulte https://swagger.io/tools/swagger-codegen/ para saber mais sobre o processo de gera\u00e7\u00e3o de clientes \u00e0 partir de uma documenta\u00e7\u00e3o.","title":"\ud83d\udcd6 Por que documentar?"},{"location":"docs/#aprimorando-nossa-documentacao","text":"Navegando por nossa api percebemos que ambos os endpoints est\u00e3o agrupados em conjunto chamado default . Podemos melhorar isto agrupando os endpoints de recursos similares utilizando tags . Hoje nossa documenta\u00e7\u00e3o est\u00e1 assim: Modificando ambos os endpoints para serem agrupados por tags, ficamos assim: api_pedidos/api.py # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ]) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , tags = [ \"pedidos\" ]) # ... Uma outra melhoria que podemos fazer em nossa documenta\u00e7\u00e3o \u00e9 aprimorar a exibi\u00e7\u00e3o de cada um dos endpoints (hoje a descri\u00e7\u00e3o curta \u00e9 apenas o nome da fun\u00e7\u00e3o que utilizamos). Essa altera\u00e7\u00e3o ser\u00e1 feita no arquivo api_pedidos/api.py : api_pedidos/api.py # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" ) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , tags = [ \"pedidos\" ], summary = \"Itens de um pedido\" ) # ... Vamos adicionar tamb\u00e9m uma descri\u00e7\u00e3o mais detalhada para cada endpoint . # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" ) # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" ) # ... Uma outra melhoria seria tornar expl\u00edcito o retorno dos endpoints desenvolvidos at\u00e9 agora. Come\u00e7ando pelo healthcheck : Antes da melhoria, a documenta\u00e7\u00e3o era assim: api_pedidos/esquema.py # ... class HealthCheckResponse ( BaseModel ): status : str api_pedidos/api.py from api_pedidos.esquema import HealthCheckResponse , Item # ... @app . get ( \"/healthcheck\" , tags = [ \"healthcheck\" ], summary = \"Integridade do sistema\" , description = \"Checa se o servidor est\u00e1 online\" , response_model = HealthCheckResponse ) def healthcheck (): return HealthCheckResponse ( status = \"ok\" ) # ... Ap\u00f3s a melhoria, a documenta\u00e7\u00e3o fica assim: Vamos fazer um ajuste similar para o endpoint de pedidos : Antes da melhoria, a documenta\u00e7\u00e3o era assim: api_pedidos/api.py # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ]) # ... Warning Se estiver utilizando Python na em vers\u00f5es anteriores a 3.9, deve-se utilizar o tipo List[Item] para o retorno do endpoint. Depois da melhoria, a documenta\u00e7\u00e3o fica assim: Durante a implementa\u00e7\u00e3o n\u00f3s definimos alguns cen\u00e1rios poss\u00edveis como o pedido n\u00e3o existir, ou n\u00e3o conseguir se comunicar com a API externa. Mas estes retornos n\u00e3o est\u00e3o sinalizados na nossa documenta\u00e7\u00e3o. Vamos adicion\u00e1-los?! Primeira coisa, talvez seja interessante padronizarmos os retornos de erro da nossa api em um esquema. api_pedidos/esquema.py # ... class ErrorResponse ( BaseModel ): message : str Depois disso vamos adicionar o esquema de retorno de erro na documenta\u00e7\u00e3o: # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" , responses = { HTTPStatus . NOT_FOUND . value : { \"description\" : \"Pedido n\u00e3o encontrado\" , \"model\" : ErrorResponse , }, HTTPStatus . BAD_GATEWAY . value : { \"description\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" , \"model\" : ErrorResponse , }}, summary = \"Itens de um pedido\" , tags = [ \"pedidos\" ], description = \"Retorna todos os itens de um determinado pedido\" , response_model = list [ Item ]) # ... \ud83d\udc81 Ainda temos outras customiza\u00e7\u00f5es na documenta\u00e7\u00e3o que podem ser interessantes como exemplos de entradas e sa\u00eddas. Para mais exemplos consulte: https://fastapi.tiangolo.com/advanced/additional-responses/ \ud83e\udd73 Agora nossa api est\u00e1 documentada! Ficou muito mais f\u00e1cil para algu\u00e9m que queira se integrar a sua API. Mas n\u00e3o se esque\u00e7a de manter a documenta\u00e7\u00e3o sempre atualizada!","title":"\ud83d\udcd4 Aprimorando nossa documenta\u00e7\u00e3o"},{"location":"docs/#salvando-a-versao-atual-do-codigo","text":"Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py modified: api_pedidos/esquema.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar as mudan\u00e7as nesta revis\u00e3o. git add api_pedidos/api.py api_pedidos/esquema.py \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Adiciona documenta\u00e7\u00e3o ao projeto\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Agora que temos uma api e documenta\u00e7\u00e3o, vamos dar um pr\u00f3ximo passo na qualidade e evolu\u00e7\u00e3o do nosso projeto. Cumprimos mais um requisito: Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; \ud83d\udc02 Uma api robusta possui boa documenta\u00e7\u00e3o facilitando assim uma integra\u00e7\u00e3o externa.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"explorando_api/","text":"\ud83d\uddfa\ufe0f Explorando a API do Magalu A API do Marketplace da Magalu oferece acesso program\u00e1tico a uma variedade de funcionalidades, expostas como endpoints REST , acess\u00edveis via HTTPS. Com esta API voc\u00ea pode: Escrever aplica\u00e7\u00f5es que utilizam todos os recursos da API, agindo em nome de um usu\u00e1rio final, como por exemplo, um parceiro Magalu vendendo produtos no marketplace; Consultar seus pedidos de venda, aceit\u00e1-los e realizar os passos essenciais para sua opera\u00e7\u00e3o, incluindo faturamento e envio; Atender e responder a chamados abertos sobre suas vendas e os produtos vendidos. Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". N\u00e3o deixe de explorar a API como demonstrado acima, mesmo que seja sua vers\u00e3o simulada. Acesse a p\u00e1gina para desenvolvedores: https://alpha.dev.magalu.com/ Warning O portal do desenvolvedor ainda est\u00e1 em alpha e seu uso \u00e9 restrito. Durante o tutorial vamos liberar o acesso ao portal para que voc\u00ea possa testar a API. Ap\u00f3s estar autorizado, vamos precisar de uma chave para acessar a API. Podemos obter o valor desta chave clicando em painel . Com a chave de acesso (APIKEY) em m\u00e3os, vamos explorar alguns endpoints. Tip Lugares onde encontrar <APIKEY> , substitua pelo valor que voc\u00ea obteve no painel. Primeiro vamos verificar se sua conta est\u00e1 ativa. Utilize o seguinte comando: http https://alpha.api.magalu.com/account/v1/whoami X-API-KEY:<APIKEY> A API apresenta um conceito chamado de tenant que representa qual a vis\u00e3o do dado que voc\u00ea est\u00e1 acessando. Uma mesma conta pode possuir v\u00e1rias visualiza\u00e7\u00f5es, como por exemplo, uma para consumidor e outra para vendas de produtos. Aqui focaremos somente na vis\u00e3o de um vendedor (seller) e utilizaremos o tenant stenagam que \u00e9 uma vis\u00e3o de dados fict\u00edcios utilizados para testes. Para mais detalhes sobre tenants e perspectivas acesse Tenants e Perspectivas . http https://alpha.api.magalu.com/account/v1/whoami/tenants X-API-KEY:<APIKEY> Copie a identifica\u00e7\u00e3o (uuid) do tenant stenagam.SELLER para ser utilizado nas pr\u00f3ximas requisi\u00e7\u00f5es. Pr\u00f3ximo passo \u00e9 explorar a consulta de pedidos e seus itens. http https://alpha.api.magalu.com/maestro/v1/orders X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Podemos verificar tamb\u00e9m um pedido em espec\u00edfico. http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Assim como podemos consultar uma lista de produtos a partir de um pedido e seu respectivo pacote. http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e/packages/0ebc7451-322a-4329-a7c3-9d01189f4503 X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 ou ainda mais espec\u00edfico: http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e/packages/0ebc7451-322a-4329-a7c3-9d01189f4503/items X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Dado estes endpoints, parece que precisamos fazer uma primeira consulta para obter os pacotes de um pedido e em seguida realizar a requisi\u00e7\u00e3o para obter os itens de um pedido. Para mais detalhes sobre a api consulte API Maestro \u21a9\ufe0f Voltar","title":"\ud83d\uddfa\ufe0f Explorando a API do Magalu"},{"location":"explorando_api/#explorando-a-api-do-magalu","text":"A API do Marketplace da Magalu oferece acesso program\u00e1tico a uma variedade de funcionalidades, expostas como endpoints REST , acess\u00edveis via HTTPS. Com esta API voc\u00ea pode: Escrever aplica\u00e7\u00f5es que utilizam todos os recursos da API, agindo em nome de um usu\u00e1rio final, como por exemplo, um parceiro Magalu vendendo produtos no marketplace; Consultar seus pedidos de venda, aceit\u00e1-los e realizar os passos essenciais para sua opera\u00e7\u00e3o, incluindo faturamento e envio; Atender e responder a chamados abertos sobre suas vendas e os produtos vendidos. Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". N\u00e3o deixe de explorar a API como demonstrado acima, mesmo que seja sua vers\u00e3o simulada. Acesse a p\u00e1gina para desenvolvedores: https://alpha.dev.magalu.com/ Warning O portal do desenvolvedor ainda est\u00e1 em alpha e seu uso \u00e9 restrito. Durante o tutorial vamos liberar o acesso ao portal para que voc\u00ea possa testar a API. Ap\u00f3s estar autorizado, vamos precisar de uma chave para acessar a API. Podemos obter o valor desta chave clicando em painel . Com a chave de acesso (APIKEY) em m\u00e3os, vamos explorar alguns endpoints. Tip Lugares onde encontrar <APIKEY> , substitua pelo valor que voc\u00ea obteve no painel. Primeiro vamos verificar se sua conta est\u00e1 ativa. Utilize o seguinte comando: http https://alpha.api.magalu.com/account/v1/whoami X-API-KEY:<APIKEY> A API apresenta um conceito chamado de tenant que representa qual a vis\u00e3o do dado que voc\u00ea est\u00e1 acessando. Uma mesma conta pode possuir v\u00e1rias visualiza\u00e7\u00f5es, como por exemplo, uma para consumidor e outra para vendas de produtos. Aqui focaremos somente na vis\u00e3o de um vendedor (seller) e utilizaremos o tenant stenagam que \u00e9 uma vis\u00e3o de dados fict\u00edcios utilizados para testes. Para mais detalhes sobre tenants e perspectivas acesse Tenants e Perspectivas . http https://alpha.api.magalu.com/account/v1/whoami/tenants X-API-KEY:<APIKEY> Copie a identifica\u00e7\u00e3o (uuid) do tenant stenagam.SELLER para ser utilizado nas pr\u00f3ximas requisi\u00e7\u00f5es. Pr\u00f3ximo passo \u00e9 explorar a consulta de pedidos e seus itens. http https://alpha.api.magalu.com/maestro/v1/orders X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Podemos verificar tamb\u00e9m um pedido em espec\u00edfico. http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Assim como podemos consultar uma lista de produtos a partir de um pedido e seu respectivo pacote. http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e/packages/0ebc7451-322a-4329-a7c3-9d01189f4503 X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 ou ainda mais espec\u00edfico: http https://alpha.api.magalu.com/maestro/v1/orders/0b529f98-3a4a-4d2b-8970-96ef0f0e1c2e/packages/0ebc7451-322a-4329-a7c3-9d01189f4503/items X-API-KEY:<APIKEY> X-TENANT-ID:21fea73c-e244-497a-8540-be0d3c583596 Dado estes endpoints, parece que precisamos fazer uma primeira consulta para obter os pacotes de um pedido e em seguida realizar a requisi\u00e7\u00e3o para obter os itens de um pedido. Para mais detalhes sobre a api consulte API Maestro \u21a9\ufe0f Voltar","title":"\ud83d\uddfa\ufe0f Explorando a API do Magalu"},{"location":"externos/","text":"\ud83e\udd1d Integra\u00e7\u00e3o com servi\u00e7os externos Certo, temos a verifica\u00e7\u00e3o da integridade do sistema, mas ainda temos outras funcionalidades a serem implementadas. Nossa pr\u00f3xima tarefa ser\u00e1: Dado um pedido, retornar os seus itens Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. Mas antes disto, precisamos conhecer a API que iremos integrar. Vamos explorar a API do Magalu . Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". N\u00e3o deixe de explorar a API como demonstrado acima, mesmo que seja sua vers\u00e3o simulada. \ud83d\udcc4 Definindo um esquema de entrada de dados e resposta Nosso cliente deseja obter os itens de um pedido, vamos assumir ent\u00e3o que ele possui a identifica\u00e7\u00e3o do mesmo. O retorno deve ser uma lista contendo a identifica\u00e7\u00e3o e a quantidade daqueles produtos. Iremos fazer a jun\u00e7\u00e3o dos pacotes. A rota para acesso desse recurso pode ser /orders/{identifica\u00e7\u00e3o do pedido}/items assim temos uma entrada de dados bem definida atrav\u00e9s da url. A identifica\u00e7\u00e3o do pedido deve ser um uuid v\u00e1lido, caso isto n\u00e3o ocorra devemos avisar que o pedido n\u00e3o foi encontrado. Nossa sa\u00edda de dados ser\u00e1 similar a apresentada abaixo: [ { \"sku\" : \"229010200\" , \"description\" : \"Kit Fraldas Huggies Turma da M\u00f4nica Supreme Care\" , \"image_url\" : \"https://a-static.mlcdn.com.br/{w}x{h}/kit-fraldas-huggies-turma-da-monica-supreme-care-tam-g-9-a-125kg-4-pacotes-com-64-unidades-cada/magazineluiza/229010200/8a99f6f5f613ef51676384884c3a10fc.jpg\" , \"reference\" : \"Tam. G 9 a 12,5kg 4 Pacotes com 64 Unidades Cada\" , \"quantity\" : 1 , } ] Vamos escrever um esquema representando esta nossa sa\u00edda de dados? Vamos criar um arquivo api_pedidos/esquema.py e dentro dele vamos adicionar o seguinte conte\u00fado: Info Utilizaremos a biblioteca pydantic para definir nosso esquema, ela j\u00e1 possui integra\u00e7\u00e3o com o FastAPI e \u00e9 uma das mais poderosas ferramentas dispon\u00edveis no mercado. from pydantic import BaseModel class Item ( BaseModel ): sku : str description : str image_url : str reference : str quantity : int \u270d\ufe0f Escrevendo c\u00f3digo Daqui pra frente sempre que ver \u274c escreva o teste mostrado e em seguida rode os testes que devem falhar. Logo em seguida dever\u00e1 aparecer \u2714\ufe0f e o trecho de c\u00f3digo que deve ser alterado. Lembre-se de rodar os testes para garantir que est\u00e3o funcionando. Como temos bem definido que a entrada de dados deve ser um uuid v\u00e1lido, vamos escrever nosso primeiro teste deste endpoint \u00e0 partir disto. \u274c tests/test_api.py def test_obter_itens_quando_receber_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY \u2714\ufe0f api_pedidos/api.py from uuid import UUID # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( identificacao_do_pedido : UUID ): pass A verifica\u00e7\u00e3o de uma identifica\u00e7\u00e3o de pedido como UUID est\u00e1 testada. Pr\u00f3ximo passo \u00e9 testar a obten\u00e7\u00e3o de um pedido e em seguida seus itens. \u274c tests/test_api.py def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND \ud83c\udf8e Vamos criar dubl\u00eas para testar a obten\u00e7\u00e3o de um pedido e seus itens, assim n\u00e3o precisamos realizar a requisi\u00e7\u00e3o real por enquanto. O dubl\u00ea pode ser escrito da seguinte maneira: def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () \u274c tests/test_api.py from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError # ... def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND Como deve ter notado, um erro acontece pois n\u00e3o definimos o nosso erro. api_pedidos/excecao.py class PedidoNaoEncontradoError ( Exception ): pass Ainda n\u00e3o estamos utilizando nosso dubl\u00ea, isso porque n\u00e3o temos uma fun\u00e7\u00e3o que retorne os itens de um pedido a ser substituida. Vamos declar\u00e1-la e avisar ao endpoint para utiliz\u00e1-la: api_pedidos/api.py from fastapi import FastAPI , Depends from api_pedidos.esquema import Item # ... def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: pass # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): return itens Estamos utilizando aqui uma t\u00e9cnica de inje\u00e7\u00e3o de depend\u00eancia . Esta t\u00e9cnica vai nos permitir mudar o recuperador de itens para um dubl\u00ea nos testes e tamb\u00e9m nos permite no futuro mudar a tecnologia/maneira utilizada para recuperar os itens de um pedido sem precisar modificar todos os lugares que dependem da fun\u00e7\u00e3o de recupera\u00e7\u00e3o de itens. A simples defini\u00e7\u00e3o da fun\u00e7\u00e3o j\u00e1 \u00e9 suficiente para que possamos modific\u00e1-la posteriormente nos testes. Vamos voltar ao nosso teste, substituir a nossa depend\u00eancia e rodar novamente. \u274c tests/test_api.py from api_pedidos.api import app , recuperar_itens_por_pedido # ... def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND Agora vamos preparar nosso sistema para tratar este erro. \u2714\ufe0f api_pedidos/api.py from api_pedidos.excecao import PedidoNaoEncontradoError from fastapi import FastAPI , Depends , Request from fastapi.responses import JSONResponse from http import HTTPStatus # ... @app . exception_handler ( PedidoNaoEncontradoError ) def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): return JSONResponse ( status_code = HTTPStatus . NOT_FOUND , content = { \"message\" : \"Pedido n\u00e3o encontrado\" }) # ... Vamos fazer um teste ent\u00e3o para quando o pedido for encontrado? Assim teremos certeza que temos o c\u00f3digo de status correto e a sa\u00edda de dados no formato esperado. \u2049\ufe0f Significa, vamos verificar se nossa api est\u00e1 correta? Rode os testes e modifique o c\u00f3digo se necess\u00e1rio. \u2049\ufe0f tests/test_api.py def test_obter_itens_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK \u2049\ufe0f tests/test_api.py def test_obter_itens_quando_encontrar_pedido_deve_retornar_itens ( cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens Neste momento o arquivo de voc\u00eas devem estar da seguinte maneira: tests/test_api.py from http import HTTPStatus import pytest from api_pedidos.api import app , recuperar_itens_por_pedido from fastapi.testclient import TestClient from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError @pytest . fixture def cliente (): return TestClient ( app ) def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } def test_obter_itens_quando_receber_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_obter_itens_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_obter_itens_quando_encontrar_pedido_deve_retornar_itens ( cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens api_pedidos/api.py from fastapi import FastAPI , Depends , Request from fastapi.responses import JSONResponse from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError from http import HTTPStatus app = FastAPI () def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: pass @app . exception_handler ( PedidoNaoEncontradoError ) def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): return JSONResponse ( status_code = HTTPStatus . NOT_FOUND , content = { \"message\" : \"Pedido n\u00e3o encontrado\" }) @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): return itens api_pedidos/esquema.py from pydantic import BaseModel class Item ( BaseModel ): sku : str description : str image_url : str reference : str quantity : int api_pedidos/excecao.py class PedidoNaoEncontradoError ( Exception ): pass \ud83e\uddd9 Refatorando o c\u00f3digo Um \u00fanico arquivo com v\u00e1rios testes est\u00e1 come\u00e7ando a ficar confuso. Que tal separarmos os testes de cada endpoint ? from http import HTTPStatus import pytest from api_pedidos.api import app , recuperar_itens_por_pedido from fastapi.testclient import TestClient from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError @pytest . fixture def cliente (): return TestClient ( app ) class TestHealthCheck : def test_devo_ter_como_retorno_codigo_de_status_200 ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_formato_de_retorno_deve_ser_json ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_deve_conter_informacoes ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } class TestListarPedidos : def test_quando_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( self , cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_quando_pedido_nao_encontrado_um_erro_deve_ser_retornado ( self , cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( self , cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_encontrar_pedido_deve_retornar_itens ( self , cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens \u2728 Aproveitei a refatora\u00e7\u00e3o e modifiquei alguns nomes dos testes. Agrupei os testes em classes separadas para facilitar a leitura. Outro detalhe importante que precisamos fazer \u00e9 modificar os testes para que eles sejam independentes dos outros testes. Como estamos modificando o app em alguns testes, seria interessante retornar para o estado inicial ao final do teste. Vamos criar uma fixture que configure um cen\u00e1rio onde a fun\u00e7\u00e3o foi modificada e ao termino retorna o app para o estado inicial. # ... @pytest . fixture def sobreescreve_recuperar_itens_por_pedido (): def _sobreescreve_recuperar_itens_por_pedido ( itens_ou_erro ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: if isinstance ( itens_ou_erro , Exception ): raise itens_ou_erro return itens_ou_erro app . dependency_overrides [ recuperar_itens_por_pedido ] = duble yield _sobreescreve_recuperar_itens_por_pedido app . dependency_overrides . clear () # ... class TestListarPedidos : def test_quando_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( self , cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_quando_pedido_nao_encontrado_um_erro_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ( PedidoNaoEncontradoError ()) resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ([]) resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_encontrar_pedido_deve_retornar_itens ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] sobreescreve_recuperar_itens_por_pedido ( itens ) resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens Embora a fixture seja um pouco mais complexa, os testes ficam mais simples e garantimos que a sobrescrita n\u00e3o propague entre os testes. \ud83d\udd17 Integrando a API do Magalu Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". Vamos iniciar um pouquinho diferente dessa vez, vamos parar a programa\u00e7\u00e3o guiada por testes e explorar a solu\u00e7\u00e3o. Depois fica como exerc\u00edcio do leitor escrever estes testes. Tip Uma dica muito importante \u00e9 a utiliza\u00e7\u00e3o de marcas nestes testes indicando que eles s\u00e3o lentos. Visto a dificuldade de simular a falha de conex\u00e3o com o servidor, normalmente os testes deste tipo se resumem a caminhos felizes ou cr\u00edticos. Para marcar um teste como lento adicione acima dele @pytest.mark.slow ou adicione a seguinte linha no m\u00f3dulo pytestmark = slow . Para evitar a execu\u00e7\u00e3o destes testes utilize pytest -m \"not slow\" Mais informa\u00e7\u00f5es em https://docs.pytest.org/en/latest/example/markers.html . Vamos olhar o c\u00f3digo de integra\u00e7\u00e3o com a API do Magalu. Este arquivo deve ser criado com o seguinte conte\u00fado. api_pedidos/magalu_api.py from http import HTTPStatus import os from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError import httpx # tenant e apikey fixos somente para demonstra\u00e7\u00f5es APIKEY = os . environ . get ( \"APIKEY\" , \"coloque aqui sua apikey\" ) TENANT_ID = os . environ . get ( \"TENANT_ID\" , \"21fea73c-e244-497a-8540-be0d3c583596\" ) MAGALU_API_URL = \"https://alpha.api.magalu.com\" MAESTRO_SERVICE_URL = f \" { MAGALU_API_URL } /maestro/v1\" def _recupera_itens_por_pacote ( uuid_do_pedido , uuid_do_pacote ): response = httpx . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { uuid_do_pedido } /packages/ { uuid_do_pacote } /items\" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () return [ Item ( sku = item [ \"product\" ][ \"code\" ], # campos que utilizam a fun\u00e7\u00e3o get s\u00e3o opicionais description = item [ \"product\" ] . get ( \"description\" , \"\" ), image_url = item [ \"product\" ] . get ( \"image_url\" , \"\" ), reference = item [ \"product\" ] . get ( \"reference\" , \"\" ), quantity = item [ \"quantity\" ], ) for item in response . json () ] def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: try : response = httpx . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { identificacao_do_pedido } \" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () pacotes = response . json ()[ \"packages\" ] itens = [] for pacote in pacotes : itens . extend ( _recupera_itens_por_pacote ( identificacao_do_pedido , pacote [ \"uuid\" ]) ) return itens except httpx . HTTPStatusError as exc : # aqui poderiam ser tratados outros erros como autentica\u00e7\u00e3o if exc . response . status_code == HTTPStatus . NOT_FOUND : raise PedidoNaoEncontradoError () from exc raise exc except httpx . HTTPError as exc : raise FalhaDeComunicacaoError () from exc \ud83d\udc81 Uma ferramenta muito interessante para testar nosso c\u00f3digo sem precisar fazer as chamadas reais a todo momento \u00e9 o vcrpy . Ele grava as respostas das requisi\u00e7\u00f5es uma \u00fanica vez e depois faz a simula\u00e7\u00e3o das chamadas. Leia o c\u00f3digo e entenda o que est\u00e1 acontecendo. Uma coisa interessante apareceu durante o desenvolvimento deste c\u00f3digo. Erros de comunica\u00e7\u00e3o com o servidor remoto precisam ser tratados. Vamos adicionar um teste para isto. \u274c tests/test_api.py from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError # ... # ... classe de testes ... def test_quando_fonte_de_pedidos_falha_um_erro_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ( FalhaDeComunicacaoError ()) resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . BAD_GATEWAY \u2714\ufe0f api_pedidos/excecao.py # ... class FalhaDeComunicacaoError ( Exception ): pass \u2714\ufe0f api_pedidos/api.py from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError # ... @app . exception_handler ( FalhaDeComunicacaoError ) def tratar_erro_falha_de_comunicacao ( request : Request , exc : FalhaDeComunicacaoError ): return JSONResponse ( status_code = HTTPStatus . BAD_GATEWAY , content = { \"message\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" }) # ... Ufa! Agora podemos testar a nossa api. Substitua a fun\u00e7\u00e3o ( recuperar_itens_por_pedido ) criada anteriormente pela nossa nova fun\u00e7\u00e3o e vamos testar manualmente nossa api. \ud83d\udd27 Testando manualmente A nossa aplica\u00e7\u00e3o pode estar ainda rodando, mas caso n\u00e3o esteja vamos inicia-la. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Vamos testar alguns cen\u00e1rios? O que acontece se passar um valor qualquer ao inv\u00e9s de um uuid v\u00e1lido? http :8000/orders/invalido/items E um pedido que n\u00e3o existe? http :8000/orders/e3ae3598-8034-4374-8eed-bdca8c31d5a0/items Por fim vamos ver um pedido que existe. http :8000/orders/efb77dcf-d83c-4935-81ac-7be5f37e6cdc/items Voc\u00ea pode testar a falha do servidor remoto modificando a url no arquivo api_pedidos/magalu_api.py . \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py modified: tests/test_api.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/esquema.py api_pedidos/excecao.py api_pedidos/magalu_api.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar ao versionamento os arquivos novos e avisar modifica\u00e7\u00f5es em alguns j\u00e1 existentes. git add api_pedidos tests \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Adiciona listagem de itens em um pedido\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Podemos marcar como pronto as seguintes tarefas: Dado um pedido, retornar os seus itens Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. \ud83d\udc02 Uma API robusta possui uma entrada de dados e resposta bem definida, facilitando assim integra\u00e7\u00e3o com outros sistemas.","title":"\ud83e\udd1d Integra\u00e7\u00e3o com servi\u00e7os externos"},{"location":"externos/#integracao-com-servicos-externos","text":"Certo, temos a verifica\u00e7\u00e3o da integridade do sistema, mas ainda temos outras funcionalidades a serem implementadas. Nossa pr\u00f3xima tarefa ser\u00e1: Dado um pedido, retornar os seus itens Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. Mas antes disto, precisamos conhecer a API que iremos integrar. Vamos explorar a API do Magalu . Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". N\u00e3o deixe de explorar a API como demonstrado acima, mesmo que seja sua vers\u00e3o simulada.","title":"\ud83e\udd1d Integra\u00e7\u00e3o com servi\u00e7os externos"},{"location":"externos/#definindo-um-esquema-de-entrada-de-dados-e-resposta","text":"Nosso cliente deseja obter os itens de um pedido, vamos assumir ent\u00e3o que ele possui a identifica\u00e7\u00e3o do mesmo. O retorno deve ser uma lista contendo a identifica\u00e7\u00e3o e a quantidade daqueles produtos. Iremos fazer a jun\u00e7\u00e3o dos pacotes. A rota para acesso desse recurso pode ser /orders/{identifica\u00e7\u00e3o do pedido}/items assim temos uma entrada de dados bem definida atrav\u00e9s da url. A identifica\u00e7\u00e3o do pedido deve ser um uuid v\u00e1lido, caso isto n\u00e3o ocorra devemos avisar que o pedido n\u00e3o foi encontrado. Nossa sa\u00edda de dados ser\u00e1 similar a apresentada abaixo: [ { \"sku\" : \"229010200\" , \"description\" : \"Kit Fraldas Huggies Turma da M\u00f4nica Supreme Care\" , \"image_url\" : \"https://a-static.mlcdn.com.br/{w}x{h}/kit-fraldas-huggies-turma-da-monica-supreme-care-tam-g-9-a-125kg-4-pacotes-com-64-unidades-cada/magazineluiza/229010200/8a99f6f5f613ef51676384884c3a10fc.jpg\" , \"reference\" : \"Tam. G 9 a 12,5kg 4 Pacotes com 64 Unidades Cada\" , \"quantity\" : 1 , } ] Vamos escrever um esquema representando esta nossa sa\u00edda de dados? Vamos criar um arquivo api_pedidos/esquema.py e dentro dele vamos adicionar o seguinte conte\u00fado: Info Utilizaremos a biblioteca pydantic para definir nosso esquema, ela j\u00e1 possui integra\u00e7\u00e3o com o FastAPI e \u00e9 uma das mais poderosas ferramentas dispon\u00edveis no mercado. from pydantic import BaseModel class Item ( BaseModel ): sku : str description : str image_url : str reference : str quantity : int","title":"\ud83d\udcc4 Definindo um esquema de entrada de dados e resposta"},{"location":"externos/#escrevendo-codigo","text":"Daqui pra frente sempre que ver \u274c escreva o teste mostrado e em seguida rode os testes que devem falhar. Logo em seguida dever\u00e1 aparecer \u2714\ufe0f e o trecho de c\u00f3digo que deve ser alterado. Lembre-se de rodar os testes para garantir que est\u00e3o funcionando. Como temos bem definido que a entrada de dados deve ser um uuid v\u00e1lido, vamos escrever nosso primeiro teste deste endpoint \u00e0 partir disto. \u274c tests/test_api.py def test_obter_itens_quando_receber_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY \u2714\ufe0f api_pedidos/api.py from uuid import UUID # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( identificacao_do_pedido : UUID ): pass A verifica\u00e7\u00e3o de uma identifica\u00e7\u00e3o de pedido como UUID est\u00e1 testada. Pr\u00f3ximo passo \u00e9 testar a obten\u00e7\u00e3o de um pedido e em seguida seus itens. \u274c tests/test_api.py def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND \ud83c\udf8e Vamos criar dubl\u00eas para testar a obten\u00e7\u00e3o de um pedido e seus itens, assim n\u00e3o precisamos realizar a requisi\u00e7\u00e3o real por enquanto. O dubl\u00ea pode ser escrito da seguinte maneira: def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () \u274c tests/test_api.py from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError # ... def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND Como deve ter notado, um erro acontece pois n\u00e3o definimos o nosso erro. api_pedidos/excecao.py class PedidoNaoEncontradoError ( Exception ): pass Ainda n\u00e3o estamos utilizando nosso dubl\u00ea, isso porque n\u00e3o temos uma fun\u00e7\u00e3o que retorne os itens de um pedido a ser substituida. Vamos declar\u00e1-la e avisar ao endpoint para utiliz\u00e1-la: api_pedidos/api.py from fastapi import FastAPI , Depends from api_pedidos.esquema import Item # ... def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: pass # ... @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): return itens Estamos utilizando aqui uma t\u00e9cnica de inje\u00e7\u00e3o de depend\u00eancia . Esta t\u00e9cnica vai nos permitir mudar o recuperador de itens para um dubl\u00ea nos testes e tamb\u00e9m nos permite no futuro mudar a tecnologia/maneira utilizada para recuperar os itens de um pedido sem precisar modificar todos os lugares que dependem da fun\u00e7\u00e3o de recupera\u00e7\u00e3o de itens. A simples defini\u00e7\u00e3o da fun\u00e7\u00e3o j\u00e1 \u00e9 suficiente para que possamos modific\u00e1-la posteriormente nos testes. Vamos voltar ao nosso teste, substituir a nossa depend\u00eancia e rodar novamente. \u274c tests/test_api.py from api_pedidos.api import app , recuperar_itens_por_pedido # ... def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND Agora vamos preparar nosso sistema para tratar este erro. \u2714\ufe0f api_pedidos/api.py from api_pedidos.excecao import PedidoNaoEncontradoError from fastapi import FastAPI , Depends , Request from fastapi.responses import JSONResponse from http import HTTPStatus # ... @app . exception_handler ( PedidoNaoEncontradoError ) def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): return JSONResponse ( status_code = HTTPStatus . NOT_FOUND , content = { \"message\" : \"Pedido n\u00e3o encontrado\" }) # ... Vamos fazer um teste ent\u00e3o para quando o pedido for encontrado? Assim teremos certeza que temos o c\u00f3digo de status correto e a sa\u00edda de dados no formato esperado. \u2049\ufe0f Significa, vamos verificar se nossa api est\u00e1 correta? Rode os testes e modifique o c\u00f3digo se necess\u00e1rio. \u2049\ufe0f tests/test_api.py def test_obter_itens_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK \u2049\ufe0f tests/test_api.py def test_obter_itens_quando_encontrar_pedido_deve_retornar_itens ( cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens Neste momento o arquivo de voc\u00eas devem estar da seguinte maneira: tests/test_api.py from http import HTTPStatus import pytest from api_pedidos.api import app , recuperar_itens_por_pedido from fastapi.testclient import TestClient from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError @pytest . fixture def cliente (): return TestClient ( app ) def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } def test_obter_itens_quando_receber_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_obter_itens_quando_identificacao_do_pedido_nao_encontrado_um_erro_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_obter_itens_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_obter_itens_quando_encontrar_pedido_deve_retornar_itens ( cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens api_pedidos/api.py from fastapi import FastAPI , Depends , Request from fastapi.responses import JSONResponse from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError from http import HTTPStatus app = FastAPI () def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: pass @app . exception_handler ( PedidoNaoEncontradoError ) def tratar_erro_pedido_nao_encontrado ( request : Request , exc : PedidoNaoEncontradoError ): return JSONResponse ( status_code = HTTPStatus . NOT_FOUND , content = { \"message\" : \"Pedido n\u00e3o encontrado\" }) @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } @app . get ( \"/orders/ {identificacao_do_pedido} /items\" ) def listar_itens ( itens : list [ Item ] = Depends ( recuperar_itens_por_pedido )): return itens api_pedidos/esquema.py from pydantic import BaseModel class Item ( BaseModel ): sku : str description : str image_url : str reference : str quantity : int api_pedidos/excecao.py class PedidoNaoEncontradoError ( Exception ): pass","title":"\u270d\ufe0f Escrevendo c\u00f3digo"},{"location":"externos/#refatorando-o-codigo","text":"Um \u00fanico arquivo com v\u00e1rios testes est\u00e1 come\u00e7ando a ficar confuso. Que tal separarmos os testes de cada endpoint ? from http import HTTPStatus import pytest from api_pedidos.api import app , recuperar_itens_por_pedido from fastapi.testclient import TestClient from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError @pytest . fixture def cliente (): return TestClient ( app ) class TestHealthCheck : def test_devo_ter_como_retorno_codigo_de_status_200 ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_formato_de_retorno_deve_ser_json ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_deve_conter_informacoes ( self , cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } class TestListarPedidos : def test_quando_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( self , cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_quando_pedido_nao_encontrado_um_erro_deve_ser_retornado ( self , cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: raise PedidoNaoEncontradoError () app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( self , cliente ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return [] app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_encontrar_pedido_deve_retornar_itens ( self , cliente ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: return itens app . dependency_overrides [ recuperar_itens_por_pedido ] = duble resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens \u2728 Aproveitei a refatora\u00e7\u00e3o e modifiquei alguns nomes dos testes. Agrupei os testes em classes separadas para facilitar a leitura. Outro detalhe importante que precisamos fazer \u00e9 modificar os testes para que eles sejam independentes dos outros testes. Como estamos modificando o app em alguns testes, seria interessante retornar para o estado inicial ao final do teste. Vamos criar uma fixture que configure um cen\u00e1rio onde a fun\u00e7\u00e3o foi modificada e ao termino retorna o app para o estado inicial. # ... @pytest . fixture def sobreescreve_recuperar_itens_por_pedido (): def _sobreescreve_recuperar_itens_por_pedido ( itens_ou_erro ): def duble ( identificacao_do_pedido : UUID ) -> list [ Item ]: if isinstance ( itens_ou_erro , Exception ): raise itens_ou_erro return itens_ou_erro app . dependency_overrides [ recuperar_itens_por_pedido ] = duble yield _sobreescreve_recuperar_itens_por_pedido app . dependency_overrides . clear () # ... class TestListarPedidos : def test_quando_identificacao_do_pedido_invalido_um_erro_deve_ser_retornado ( self , cliente ): resposta = cliente . get ( \"/orders/valor-invalido/items\" ) assert resposta . status_code == HTTPStatus . UNPROCESSABLE_ENTITY def test_quando_pedido_nao_encontrado_um_erro_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ( PedidoNaoEncontradoError ()) resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . NOT_FOUND def test_quando_encontrar_pedido_codigo_ok_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ([]) resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_encontrar_pedido_deve_retornar_itens ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): itens = [ Item ( sku = '1' , description = 'Item 1' , image_url = 'http://url.com/img1' , reference = 'ref1' , quantity = 1 ), Item ( sku = '2' , description = 'Item 2' , image_url = 'http://url.com/img2' , reference = 'ref2' , quantity = 2 ), ] sobreescreve_recuperar_itens_por_pedido ( itens ) resposta = cliente . get ( \"/orders/7e290683-d67b-4f96-a940-44bef1f69d21/items\" ) assert resposta . json () == itens Embora a fixture seja um pouco mais complexa, os testes ficam mais simples e garantimos que a sobrescrita n\u00e3o propague entre os testes.","title":"\ud83e\uddd9 Refatorando o c\u00f3digo"},{"location":"externos/#integrando-a-api-do-magalu","text":"Warning Como as APIs abertas do Magalu se encontram em alpha, uma autoriza\u00e7\u00e3o pr\u00e9via \u00e9 necess\u00e1ria. Por isso, voc\u00ea pode utilizar uma vers\u00e3o simulada da mesma. As instru\u00e7\u00f5es de instala\u00e7\u00e3o e execu\u00e7\u00e3o se encontram no readme do projeto . Lembre-se de trocar \"https://alpha.dev.magalu.com/\" por \"http://localhost:8080\". A APIKEY utilizada no acesso simulado \u00e9 \"5734143a-595d-405d-9c97-6c198537108f\". Vamos iniciar um pouquinho diferente dessa vez, vamos parar a programa\u00e7\u00e3o guiada por testes e explorar a solu\u00e7\u00e3o. Depois fica como exerc\u00edcio do leitor escrever estes testes. Tip Uma dica muito importante \u00e9 a utiliza\u00e7\u00e3o de marcas nestes testes indicando que eles s\u00e3o lentos. Visto a dificuldade de simular a falha de conex\u00e3o com o servidor, normalmente os testes deste tipo se resumem a caminhos felizes ou cr\u00edticos. Para marcar um teste como lento adicione acima dele @pytest.mark.slow ou adicione a seguinte linha no m\u00f3dulo pytestmark = slow . Para evitar a execu\u00e7\u00e3o destes testes utilize pytest -m \"not slow\" Mais informa\u00e7\u00f5es em https://docs.pytest.org/en/latest/example/markers.html . Vamos olhar o c\u00f3digo de integra\u00e7\u00e3o com a API do Magalu. Este arquivo deve ser criado com o seguinte conte\u00fado. api_pedidos/magalu_api.py from http import HTTPStatus import os from uuid import UUID from api_pedidos.esquema import Item from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError import httpx # tenant e apikey fixos somente para demonstra\u00e7\u00f5es APIKEY = os . environ . get ( \"APIKEY\" , \"coloque aqui sua apikey\" ) TENANT_ID = os . environ . get ( \"TENANT_ID\" , \"21fea73c-e244-497a-8540-be0d3c583596\" ) MAGALU_API_URL = \"https://alpha.api.magalu.com\" MAESTRO_SERVICE_URL = f \" { MAGALU_API_URL } /maestro/v1\" def _recupera_itens_por_pacote ( uuid_do_pedido , uuid_do_pacote ): response = httpx . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { uuid_do_pedido } /packages/ { uuid_do_pacote } /items\" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () return [ Item ( sku = item [ \"product\" ][ \"code\" ], # campos que utilizam a fun\u00e7\u00e3o get s\u00e3o opicionais description = item [ \"product\" ] . get ( \"description\" , \"\" ), image_url = item [ \"product\" ] . get ( \"image_url\" , \"\" ), reference = item [ \"product\" ] . get ( \"reference\" , \"\" ), quantity = item [ \"quantity\" ], ) for item in response . json () ] def recuperar_itens_por_pedido ( identificacao_do_pedido : UUID ) -> list [ Item ]: try : response = httpx . get ( f \" { MAESTRO_SERVICE_URL } /orders/ { identificacao_do_pedido } \" , headers = { \"X-Api-Key\" : APIKEY , \"X-Tenant-Id\" : TENANT_ID }, ) response . raise_for_status () pacotes = response . json ()[ \"packages\" ] itens = [] for pacote in pacotes : itens . extend ( _recupera_itens_por_pacote ( identificacao_do_pedido , pacote [ \"uuid\" ]) ) return itens except httpx . HTTPStatusError as exc : # aqui poderiam ser tratados outros erros como autentica\u00e7\u00e3o if exc . response . status_code == HTTPStatus . NOT_FOUND : raise PedidoNaoEncontradoError () from exc raise exc except httpx . HTTPError as exc : raise FalhaDeComunicacaoError () from exc \ud83d\udc81 Uma ferramenta muito interessante para testar nosso c\u00f3digo sem precisar fazer as chamadas reais a todo momento \u00e9 o vcrpy . Ele grava as respostas das requisi\u00e7\u00f5es uma \u00fanica vez e depois faz a simula\u00e7\u00e3o das chamadas. Leia o c\u00f3digo e entenda o que est\u00e1 acontecendo. Uma coisa interessante apareceu durante o desenvolvimento deste c\u00f3digo. Erros de comunica\u00e7\u00e3o com o servidor remoto precisam ser tratados. Vamos adicionar um teste para isto. \u274c tests/test_api.py from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError # ... # ... classe de testes ... def test_quando_fonte_de_pedidos_falha_um_erro_deve_ser_retornado ( self , cliente , sobreescreve_recuperar_itens_por_pedido ): sobreescreve_recuperar_itens_por_pedido ( FalhaDeComunicacaoError ()) resposta = cliente . get ( \"/orders/ea78b59b-885d-4e7b-9cd0-d54acadb4933/items\" ) assert resposta . status_code == HTTPStatus . BAD_GATEWAY \u2714\ufe0f api_pedidos/excecao.py # ... class FalhaDeComunicacaoError ( Exception ): pass \u2714\ufe0f api_pedidos/api.py from api_pedidos.excecao import PedidoNaoEncontradoError , FalhaDeComunicacaoError # ... @app . exception_handler ( FalhaDeComunicacaoError ) def tratar_erro_falha_de_comunicacao ( request : Request , exc : FalhaDeComunicacaoError ): return JSONResponse ( status_code = HTTPStatus . BAD_GATEWAY , content = { \"message\" : \"Falha de comunica\u00e7\u00e3o com o servidor remoto\" }) # ... Ufa! Agora podemos testar a nossa api. Substitua a fun\u00e7\u00e3o ( recuperar_itens_por_pedido ) criada anteriormente pela nossa nova fun\u00e7\u00e3o e vamos testar manualmente nossa api.","title":"\ud83d\udd17 Integrando a API do Magalu"},{"location":"externos/#testando-manualmente","text":"A nossa aplica\u00e7\u00e3o pode estar ainda rodando, mas caso n\u00e3o esteja vamos inicia-la. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Vamos testar alguns cen\u00e1rios? O que acontece se passar um valor qualquer ao inv\u00e9s de um uuid v\u00e1lido? http :8000/orders/invalido/items E um pedido que n\u00e3o existe? http :8000/orders/e3ae3598-8034-4374-8eed-bdca8c31d5a0/items Por fim vamos ver um pedido que existe. http :8000/orders/efb77dcf-d83c-4935-81ac-7be5f37e6cdc/items Voc\u00ea pode testar a falha do servidor remoto modificando a url no arquivo api_pedidos/magalu_api.py .","title":"\ud83d\udd27 Testando manualmente"},{"location":"externos/#salvando-a-versao-atual-do-codigo","text":"Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: api_pedidos/api.py modified: tests/test_api.py Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/esquema.py api_pedidos/excecao.py api_pedidos/magalu_api.py no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Vamos adicionar ao versionamento os arquivos novos e avisar modifica\u00e7\u00f5es em alguns j\u00e1 existentes. git add api_pedidos tests \ud83d\udcbe Agora vamos consolidar uma nova vers\u00e3o. git commit -m \"Adiciona listagem de itens em um pedido\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Podemos marcar como pronto as seguintes tarefas: Dado um pedido, retornar os seus itens Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade. \ud83d\udc02 Uma API robusta possui uma entrada de dados e resposta bem definida, facilitando assim integra\u00e7\u00e3o com outros sistemas.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"ferramentas/","text":"\ud83e\uddf0 Escolhendo as melhores ferramentas \ud83d\udee0\ufe0f Ferramentas Assim como um carpinteiro, eletricista, o programador precisa de ferramentas para trabalhar. E boas ferramentas ajudam a desempenhar melhor o seu trabalho. Escolher as melhores ferramentas faz parte do seu trabalho. Quote Para quem tem um martelo, todo parafuso \u00e9 prego. Para o tutorial foram escolhidas ferramentas pensando na did\u00e1tica da pessoa desenvolvedora assim como compatibilidade de sistemas operacionais e tamb\u00e9m por serem as principais escolhas no mercado de trabalho. Para garantir o acompanhamento do tutorial, verifique se as ferramentas apresentadas a seguir est\u00e3o instaladas e funcionando. \ud83d\udc0d Python Warning \u00c9 necess\u00e1rio vers\u00e3o igual ou acima da vers\u00e3o 3.7 para acompanhar o curso. O que \u00e9? Python \u00e9 uma linguagem de programa\u00e7\u00e3o com foco em legibilidade e produtividade, criada para escrever c\u00f3digo bom e de f\u00e1cil manuten\u00e7\u00e3o de uma maneira r\u00e1pida. Para que serve? \u00c9 uma linguagem bastante vers\u00e1til, e hoje em dia \u00e9 amplamente utilizada para escrever sistemas web, integra\u00e7\u00f5es entre sistemas, ci\u00eancia de dados, automatizar tarefas e muitas outras coisas Como instalar? Vers\u00f5es mais recentes do sistema operacional linux j\u00e1 possuem o python em sua vers\u00e3o 3 instalado. Para usu\u00e1rios de Mac ou Windows voc\u00eas podem seguir os seguintes tutoriais respectivamente: Instalando o Python no Windows Instalando o Python no Mac Vamos verificar se deu tudo certo? Abra um terminal e digite: python --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: Python 3.10.0 \ud83c\udfed Pyenv (n\u00e3o obrigat\u00f3rio) Algumas vezes a vers\u00e3o do python do sistema operacional se torna obsoleta ou o projeto que est\u00e1 trabalhando \u00e9 incompat\u00edvel com a vers\u00e3o do python do sistema operacional. Existe uma ferramenta que nos ajuda a resolver este problema, gerenciando diferentes instala\u00e7\u00f5es do python no sistema operacional. Se quiser utiliza-la, siga este guia . Info Esta ferramenta n\u00e3o \u00e9 necess\u00e1ria neste tutorial mas pode ser bem \u00fatil no seu dia a dia. \ud83d\udce6 Poetry O que \u00e9? Poetry \u00e9 uma ferramenta de gerenciamento de depend\u00eancias do python. Auxilia na instala\u00e7\u00e3o de pacotes e ajuda na configura\u00e7\u00e3o do ambiente de desenvolvimento. Para que serve? Utilizaremos o poetry para controlar a vers\u00e3o das bibliotecas utilizadas para desenvolvimento do sistema. Com ele podemos baixar uma vers\u00e3o espec\u00edfica de uma biblioteca ou facilmente atualizar suas depend\u00eancias. Ele tamb\u00e9m nos ajuda a manter um ambiente isolado de desenvolvimento entre pacotes e depend\u00eancias. O poetry nos ajuda a ter um ambiente separado para cada projeto. Como instalar? Abra um terminal e digite: curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/install-poetry.py | python - Existem outras op\u00e7\u00f5es de instala\u00e7\u00e3o mas esta \u00e9 a mais recomendada. Vamos verificar se deu tudo certo? Abra um terminal e digite: poetry --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: Poetry version 1.1.11 \ud83d\udc31 Git Git \u00e9 um controle de vers\u00e3o livre e de c\u00f3digo aberto, constru\u00eddo para lidar com projetos pequenos e grandes de maneira r\u00e1pida e eficiente. Para que serve? Com certeza voc\u00ea j\u00e1 escreveu um arquivo, mais tarde trocou algumas coisas e no fim salvou com o nome versao_final.doc . Mais tarde ou no outro dia voc\u00ea decide fazer mais mudan\u00e7as e chama de agoravai.doc e quando menos percebe j\u00e1 tem um monte de arquivos e talvez nem se lembre mais qual a \u00faltima vers\u00e3o. \u00c9 para gerenciar altera\u00e7\u00f5es feitas no projeto durante o tempo que serve esta ferramenta. Durante o curso vamos salvando cada progresso feito sem precisar de ter v\u00e1rias c\u00f3pias do mesmo arquivo. Como instalar \u00c9 possivel encontrar instru\u00e7\u00f5es de instala\u00e7\u00e3o para cada um dos sistemas operacionais mais utilizados: Mac Linux Windows Vamos verificar se deu tudo certo? Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .33.0 \u2328\ufe0f VS Code O que \u00e9? O VSCode \u00e9 um editor de texto e possui uma excelente extens\u00e3o para Python que pode ser instalada atrav\u00e9s da marketplace . Para que serve? O plugin de Python para VSCode fornece auto-complete , integra\u00e7\u00e3o com os linters mais conhecidos, tamb\u00e9m \u00e9 uma ferramenta para depura\u00e7\u00e3o de c\u00f3digo. Como instalar? O VS Code pode ser baixado no site oficial aqui . A instala\u00e7\u00e3o do _ plugin_ de Python pode ser feita atrav\u00e9s da marketplace ou atrav\u00e9s dos comandos abaixo: Abra o VS Code Quick Open (Ctrl+P) , cole o comando a seguir e pressione enter . ext install ms-python.python Vamos verificar se deu tudo certo? Voc\u00ea pode abrir o VS Code e verificar se o plugin foi instalado com sucesso. \ud83c\udf89 Parab\u00e9ns! Instalamos todas as ferramentas que precisaremos para acompanhar este curso, vamos para o pr\u00f3ximo passo!","title":"\ud83e\uddf0 Escolhendo as melhores ferramentas"},{"location":"ferramentas/#escolhendo-as-melhores-ferramentas","text":"","title":"\ud83e\uddf0 Escolhendo as melhores ferramentas"},{"location":"ferramentas/#ferramentas","text":"Assim como um carpinteiro, eletricista, o programador precisa de ferramentas para trabalhar. E boas ferramentas ajudam a desempenhar melhor o seu trabalho. Escolher as melhores ferramentas faz parte do seu trabalho. Quote Para quem tem um martelo, todo parafuso \u00e9 prego. Para o tutorial foram escolhidas ferramentas pensando na did\u00e1tica da pessoa desenvolvedora assim como compatibilidade de sistemas operacionais e tamb\u00e9m por serem as principais escolhas no mercado de trabalho. Para garantir o acompanhamento do tutorial, verifique se as ferramentas apresentadas a seguir est\u00e3o instaladas e funcionando.","title":"\ud83d\udee0\ufe0f Ferramentas"},{"location":"ferramentas/#python","text":"Warning \u00c9 necess\u00e1rio vers\u00e3o igual ou acima da vers\u00e3o 3.7 para acompanhar o curso.","title":"\ud83d\udc0d Python"},{"location":"ferramentas/#o-que-e","text":"Python \u00e9 uma linguagem de programa\u00e7\u00e3o com foco em legibilidade e produtividade, criada para escrever c\u00f3digo bom e de f\u00e1cil manuten\u00e7\u00e3o de uma maneira r\u00e1pida.","title":"O que \u00e9?"},{"location":"ferramentas/#para-que-serve","text":"\u00c9 uma linguagem bastante vers\u00e1til, e hoje em dia \u00e9 amplamente utilizada para escrever sistemas web, integra\u00e7\u00f5es entre sistemas, ci\u00eancia de dados, automatizar tarefas e muitas outras coisas","title":"Para que serve?"},{"location":"ferramentas/#como-instalar","text":"Vers\u00f5es mais recentes do sistema operacional linux j\u00e1 possuem o python em sua vers\u00e3o 3 instalado. Para usu\u00e1rios de Mac ou Windows voc\u00eas podem seguir os seguintes tutoriais respectivamente: Instalando o Python no Windows Instalando o Python no Mac","title":"Como instalar?"},{"location":"ferramentas/#vamos-verificar-se-deu-tudo-certo","text":"Abra um terminal e digite: python --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: Python 3.10.0","title":"Vamos verificar se deu tudo certo?"},{"location":"ferramentas/#pyenv-nao-obrigatorio","text":"Algumas vezes a vers\u00e3o do python do sistema operacional se torna obsoleta ou o projeto que est\u00e1 trabalhando \u00e9 incompat\u00edvel com a vers\u00e3o do python do sistema operacional. Existe uma ferramenta que nos ajuda a resolver este problema, gerenciando diferentes instala\u00e7\u00f5es do python no sistema operacional. Se quiser utiliza-la, siga este guia . Info Esta ferramenta n\u00e3o \u00e9 necess\u00e1ria neste tutorial mas pode ser bem \u00fatil no seu dia a dia.","title":"\ud83c\udfed Pyenv (n\u00e3o obrigat\u00f3rio)"},{"location":"ferramentas/#poetry","text":"","title":"\ud83d\udce6 Poetry"},{"location":"ferramentas/#o-que-e_1","text":"Poetry \u00e9 uma ferramenta de gerenciamento de depend\u00eancias do python. Auxilia na instala\u00e7\u00e3o de pacotes e ajuda na configura\u00e7\u00e3o do ambiente de desenvolvimento.","title":"O que \u00e9?"},{"location":"ferramentas/#para-que-serve_1","text":"Utilizaremos o poetry para controlar a vers\u00e3o das bibliotecas utilizadas para desenvolvimento do sistema. Com ele podemos baixar uma vers\u00e3o espec\u00edfica de uma biblioteca ou facilmente atualizar suas depend\u00eancias. Ele tamb\u00e9m nos ajuda a manter um ambiente isolado de desenvolvimento entre pacotes e depend\u00eancias. O poetry nos ajuda a ter um ambiente separado para cada projeto.","title":"Para que serve?"},{"location":"ferramentas/#como-instalar_1","text":"Abra um terminal e digite: curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/install-poetry.py | python - Existem outras op\u00e7\u00f5es de instala\u00e7\u00e3o mas esta \u00e9 a mais recomendada.","title":"Como instalar?"},{"location":"ferramentas/#vamos-verificar-se-deu-tudo-certo_1","text":"Abra um terminal e digite: poetry --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: Poetry version 1.1.11","title":"Vamos verificar se deu tudo certo?"},{"location":"ferramentas/#git","text":"Git \u00e9 um controle de vers\u00e3o livre e de c\u00f3digo aberto, constru\u00eddo para lidar com projetos pequenos e grandes de maneira r\u00e1pida e eficiente. Para que serve? Com certeza voc\u00ea j\u00e1 escreveu um arquivo, mais tarde trocou algumas coisas e no fim salvou com o nome versao_final.doc . Mais tarde ou no outro dia voc\u00ea decide fazer mais mudan\u00e7as e chama de agoravai.doc e quando menos percebe j\u00e1 tem um monte de arquivos e talvez nem se lembre mais qual a \u00faltima vers\u00e3o. \u00c9 para gerenciar altera\u00e7\u00f5es feitas no projeto durante o tempo que serve esta ferramenta. Durante o curso vamos salvando cada progresso feito sem precisar de ter v\u00e1rias c\u00f3pias do mesmo arquivo. Como instalar \u00c9 possivel encontrar instru\u00e7\u00f5es de instala\u00e7\u00e3o para cada um dos sistemas operacionais mais utilizados: Mac Linux Windows Vamos verificar se deu tudo certo? Abra um terminal e digite git --version . A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: $ git --version git version 2 .33.0","title":"\ud83d\udc31 Git"},{"location":"ferramentas/#vs-code","text":"","title":"\u2328\ufe0f VS Code"},{"location":"ferramentas/#o-que-e_2","text":"O VSCode \u00e9 um editor de texto e possui uma excelente extens\u00e3o para Python que pode ser instalada atrav\u00e9s da marketplace .","title":"O que \u00e9?"},{"location":"ferramentas/#para-que-serve_2","text":"O plugin de Python para VSCode fornece auto-complete , integra\u00e7\u00e3o com os linters mais conhecidos, tamb\u00e9m \u00e9 uma ferramenta para depura\u00e7\u00e3o de c\u00f3digo.","title":"Para que serve?"},{"location":"ferramentas/#como-instalar_2","text":"O VS Code pode ser baixado no site oficial aqui . A instala\u00e7\u00e3o do _ plugin_ de Python pode ser feita atrav\u00e9s da marketplace ou atrav\u00e9s dos comandos abaixo: Abra o VS Code Quick Open (Ctrl+P) , cole o comando a seguir e pressione enter . ext install ms-python.python","title":"Como instalar?"},{"location":"ferramentas/#vamos-verificar-se-deu-tudo-certo_2","text":"Voc\u00ea pode abrir o VS Code e verificar se o plugin foi instalado com sucesso. \ud83c\udf89 Parab\u00e9ns! Instalamos todas as ferramentas que precisaremos para acompanhar este curso, vamos para o pr\u00f3ximo passo!","title":"Vamos verificar se deu tudo certo?"},{"location":"logging/","text":"\ud83d\udcdf Logging O que \u00e9? Logging \u00e9 um m\u00f3dulo nativo do python para registrar eventos. Para que serve? O Logging fornece registro de eventos de uma forma muito flex\u00edvel e funcional utilizando as se\u00e7\u00f5es Loggers, Handlers e Formatters que s\u00e3o totalmente customizados. Como usar? Primeiramente \u00e9 necess\u00e1rio uma configura\u00e7\u00e3o dos seus logs para definir o formato do seu log e como ele ser\u00e1 manipulado. Ap\u00f3s configurar o seu log, basta instanciar uma vari\u00e1vel que chame o m\u00e9todo getLogger e usar os levels que forem necess\u00e1rios para registrar os logs. Se\u00e7\u00e3o - Formatters Formatters \u00e9 a parte de configura\u00e7\u00e3o do seu log para definir como ele ser\u00e1 mostrado. Exemplo de log: 2021-10-13 22:40:40,531 - [DEBUG] api_pedidos.api [1237316] [api.healthcheck:11]: Hello healthcheck! Exemplo de uma configura\u00e7\u00e3o: { # ... \"formatters\" : { \"standard\" : { \"format\" : ( \" %(asctime)s - [ %(levelname)s ] %(name)s [ %(process)d ] \" \"[ %(module)s . %(funcName)s : %(lineno)d ]: %(message)s \" ), }, } # ... } Se\u00e7\u00e3o - Handlers Com os manipuladores de logs, \u00e9 poss\u00edvel determinar se o seu log ser\u00e1 exibido na sa\u00edda padr\u00e3o de seu terminal, em um arquivo rotacionado, criar integra\u00e7\u00f5es com outras plataformas, enviar os logs por email, etc. H\u00e1 v\u00e1rios tipos de handlers , mas os mais usados s\u00e3o: StreamHandler: Envia o log na sa\u00edda padr\u00e3o de seu terminal. RotatingFileHandler: Grava em um arquivo que \u00e9 rotacionado de acordo com o tamanho do arquivo. TimedRotatingFileHandler: Grava um arquivo que \u00e9 rotacionado de acordo com o intervalo de tempo passado. E o mais legal, \u00e9 que podemos aproveitar a sobreposi\u00e7\u00e3o de m\u00e9todos do python para manipular as classes e definir como queremos usar o log. Exemplo de uma configura\u00e7\u00e3o: { # ... \"handlers\" : { \"console\" : { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : \"standard\" }, \"discord\" : { \"level\" : \"ERROR\" , \"class\" : \"api_pedidos.core.logger_discord.DiscordStreamHandler\" , # classe que podemos herdar por exemplo do logging.StreamHandler para enviarmos atraves de um webhook para o discord \"formatter\" : \"standard\" }, \"rotating_file\" : { \"class\" : \"logging.handlers.RotatingFileHandler\" , \"filename\" : \"info.log\" , \"formatter\" : \"standard\" , \"maxBytes\" : 1048576 , # 1 mb \"backupCount\" : 2 , \"level\" : \"INFO\" , }, \"timed_rotating_file\" : { \"class\" : \"logging.handlers.TimedRotatingFileHandler\" , \"filename\" : \"timed_info.log\" , \"formatter\" : \"standard\" , \"when\" : \"midnight\" , \"interval\" : 1 , \"backupCount\" : 2 , \"level\" : \"WARNING\" , }, } # ... } Se\u00e7\u00e3o - Loggers Parte da configura\u00e7\u00e3o aonde \u00e9 determinado qual log ser\u00e1 buscado e como ele ser\u00e1 tratado chamando um handler. Exemplo de uma configura\u00e7\u00e3o: { # ... \"loggers\" : { \"api_pedidos.api\" : { \"handlers\" : [ \"timed_rotating_file\" ], \"level\" : \"DEBUG\" , }, \"api_pedidos\" : { \"handlers\" : [ \"console\" , \"rotating_file_info\" ], \"level\" : \"DEBUG\" , }, \"api_pedidos\" : { \"handlers\" : [ \"discord\" ], \"level\" : \"ERROR\" , }, }, # ... } Usando os logs Ap\u00f3s configurado, ir\u00e1 usar uma chamada parecida com esta para chamar o log em seu arquivo python: logger = logging.getLogger( name ) E registrar um log: logger.debug(\"Hello world!\") Level dos logs Os logs s\u00e3o separados em 5 levels: DEBUG, INFO, WARNING, ERROR, CRITICAL E estes levels respeitam esta ordem. Ent\u00e3o se por exemplo eu seu arquivo de configura\u00e7\u00e3o estiver no level 'INFO', nenhum log de DEBUG ser\u00e1 registrado. Exemplo de estrutura Ent\u00e3o para resumir, se fossemos incluir em nosso projeto, podemos criar uma estrutura desta forma: api_pedidos/config_logging.py import logging.config logging . config . dictConfig ( config = { \"version\" : 1 , \"formatters\" : { \"standard\" : { \"format\" : ( \" %(asctime)s - [ %(levelname)s ] %(name)s [ %(process)d ] \" \"[ %(module)s . %(funcName)s : %(lineno)d ]: %(message)s \" ), }, }, \"handlers\" : { \"console\" : { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : \"standard\" , }, }, \"loggers\" : { \"api_pedidos\" : { \"handlers\" : [ \"console\" ], \"level\" : \"DEBUG\" , }, }, }) api_pedidos/api.py from fastapi import FastAPI from api_pedidos.config_logging import logging logger = logging . getLogger ( __name__ ) app = FastAPI () @app . get ( \"/healthcheck\" ) async def healthcheck (): logger . debug ( \"Hello healthcheck!\" ) return { \"status\" : \"ok\" } \u21a9\ufe0f Voltar","title":"\ud83d\udcdf Logging"},{"location":"logging/#logging","text":"","title":"\ud83d\udcdf Logging"},{"location":"logging/#o-que-e","text":"Logging \u00e9 um m\u00f3dulo nativo do python para registrar eventos.","title":"O que \u00e9?"},{"location":"logging/#para-que-serve","text":"O Logging fornece registro de eventos de uma forma muito flex\u00edvel e funcional utilizando as se\u00e7\u00f5es Loggers, Handlers e Formatters que s\u00e3o totalmente customizados.","title":"Para que serve?"},{"location":"logging/#como-usar","text":"Primeiramente \u00e9 necess\u00e1rio uma configura\u00e7\u00e3o dos seus logs para definir o formato do seu log e como ele ser\u00e1 manipulado. Ap\u00f3s configurar o seu log, basta instanciar uma vari\u00e1vel que chame o m\u00e9todo getLogger e usar os levels que forem necess\u00e1rios para registrar os logs.","title":"Como usar?"},{"location":"logging/#secao-formatters","text":"Formatters \u00e9 a parte de configura\u00e7\u00e3o do seu log para definir como ele ser\u00e1 mostrado. Exemplo de log: 2021-10-13 22:40:40,531 - [DEBUG] api_pedidos.api [1237316] [api.healthcheck:11]: Hello healthcheck! Exemplo de uma configura\u00e7\u00e3o: { # ... \"formatters\" : { \"standard\" : { \"format\" : ( \" %(asctime)s - [ %(levelname)s ] %(name)s [ %(process)d ] \" \"[ %(module)s . %(funcName)s : %(lineno)d ]: %(message)s \" ), }, } # ... }","title":"Se\u00e7\u00e3o - Formatters"},{"location":"logging/#secao-handlers","text":"Com os manipuladores de logs, \u00e9 poss\u00edvel determinar se o seu log ser\u00e1 exibido na sa\u00edda padr\u00e3o de seu terminal, em um arquivo rotacionado, criar integra\u00e7\u00f5es com outras plataformas, enviar os logs por email, etc. H\u00e1 v\u00e1rios tipos de handlers , mas os mais usados s\u00e3o: StreamHandler: Envia o log na sa\u00edda padr\u00e3o de seu terminal. RotatingFileHandler: Grava em um arquivo que \u00e9 rotacionado de acordo com o tamanho do arquivo. TimedRotatingFileHandler: Grava um arquivo que \u00e9 rotacionado de acordo com o intervalo de tempo passado. E o mais legal, \u00e9 que podemos aproveitar a sobreposi\u00e7\u00e3o de m\u00e9todos do python para manipular as classes e definir como queremos usar o log. Exemplo de uma configura\u00e7\u00e3o: { # ... \"handlers\" : { \"console\" : { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : \"standard\" }, \"discord\" : { \"level\" : \"ERROR\" , \"class\" : \"api_pedidos.core.logger_discord.DiscordStreamHandler\" , # classe que podemos herdar por exemplo do logging.StreamHandler para enviarmos atraves de um webhook para o discord \"formatter\" : \"standard\" }, \"rotating_file\" : { \"class\" : \"logging.handlers.RotatingFileHandler\" , \"filename\" : \"info.log\" , \"formatter\" : \"standard\" , \"maxBytes\" : 1048576 , # 1 mb \"backupCount\" : 2 , \"level\" : \"INFO\" , }, \"timed_rotating_file\" : { \"class\" : \"logging.handlers.TimedRotatingFileHandler\" , \"filename\" : \"timed_info.log\" , \"formatter\" : \"standard\" , \"when\" : \"midnight\" , \"interval\" : 1 , \"backupCount\" : 2 , \"level\" : \"WARNING\" , }, } # ... }","title":"Se\u00e7\u00e3o - Handlers"},{"location":"logging/#secao-loggers","text":"Parte da configura\u00e7\u00e3o aonde \u00e9 determinado qual log ser\u00e1 buscado e como ele ser\u00e1 tratado chamando um handler. Exemplo de uma configura\u00e7\u00e3o: { # ... \"loggers\" : { \"api_pedidos.api\" : { \"handlers\" : [ \"timed_rotating_file\" ], \"level\" : \"DEBUG\" , }, \"api_pedidos\" : { \"handlers\" : [ \"console\" , \"rotating_file_info\" ], \"level\" : \"DEBUG\" , }, \"api_pedidos\" : { \"handlers\" : [ \"discord\" ], \"level\" : \"ERROR\" , }, }, # ... }","title":"Se\u00e7\u00e3o - Loggers"},{"location":"logging/#usando-os-logs","text":"Ap\u00f3s configurado, ir\u00e1 usar uma chamada parecida com esta para chamar o log em seu arquivo python: logger = logging.getLogger( name ) E registrar um log: logger.debug(\"Hello world!\")","title":"Usando os logs"},{"location":"logging/#level-dos-logs","text":"Os logs s\u00e3o separados em 5 levels: DEBUG, INFO, WARNING, ERROR, CRITICAL E estes levels respeitam esta ordem. Ent\u00e3o se por exemplo eu seu arquivo de configura\u00e7\u00e3o estiver no level 'INFO', nenhum log de DEBUG ser\u00e1 registrado.","title":"Level dos logs"},{"location":"logging/#exemplo-de-estrutura","text":"Ent\u00e3o para resumir, se fossemos incluir em nosso projeto, podemos criar uma estrutura desta forma: api_pedidos/config_logging.py import logging.config logging . config . dictConfig ( config = { \"version\" : 1 , \"formatters\" : { \"standard\" : { \"format\" : ( \" %(asctime)s - [ %(levelname)s ] %(name)s [ %(process)d ] \" \"[ %(module)s . %(funcName)s : %(lineno)d ]: %(message)s \" ), }, }, \"handlers\" : { \"console\" : { \"level\" : \"DEBUG\" , \"class\" : \"logging.StreamHandler\" , \"formatter\" : \"standard\" , }, }, \"loggers\" : { \"api_pedidos\" : { \"handlers\" : [ \"console\" ], \"level\" : \"DEBUG\" , }, }, }) api_pedidos/api.py from fastapi import FastAPI from api_pedidos.config_logging import logging logger = logging . getLogger ( __name__ ) app = FastAPI () @app . get ( \"/healthcheck\" ) async def healthcheck (): logger . debug ( \"Hello healthcheck!\" ) return { \"status\" : \"ok\" } \u21a9\ufe0f Voltar","title":"Exemplo de estrutura"},{"location":"ola_api/","text":"\ud83d\udc4b Ol\u00e1 API \u270d\ufe0f Escrevendo c\u00f3digo \u00c9 chegada a t\u00e3o esperada hora de escrevermos c\u00f3digo, por\u00e9m, como aprendemos que podemos ser guiados por testes para ajudar a concep\u00e7\u00e3o da arquitetura do nosso programa, faremos as coisas um pouco diferente. Utilizaremos os ciclos do TDD para nos auxiliarem e assim garantiremos uma qualidade de c\u00f3digo ao final. Est\u00e3o lembrados o que \u00e9 a nossa aplica\u00e7\u00e3o? Caso n\u00e3o se recorde leia o nosso planejamento novamente. Acho que podemos iniciar com os dois requisitos listados abaixo: Deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis Deve prover um endpoint que indique a sa\u00fade do sistema Mas como fazer isto se n\u00e3o temos nem mesmo uma aplica\u00e7\u00e3o ainda? Por onde come\u00e7o? Inicie criando um diret\u00f3rio com o nome tests , onde colocaremos os testes do nosso programa. L\u00e1 dentro, crie um arquivo com nome test_api.py que deve ficar da seguinte maneira: . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_api.py Agora vamos escrever nosso primeiro teste! Info O c\u00f3digo est\u00e1 escrito em portugu\u00eas para ajudar na did\u00e1tica. Para indicar a integridade do nosso sistema, vamos ter um endpoint /healthcheck , que ao receber um requisi\u00e7\u00e3o, deve retornar o c\u00f3digo de status 200 OK e este ser\u00e1 nosso primeiro teste. Traduzindo em um teste automatizado, vamos escrever o seguinte c\u00f3digo no arquivo tests/test_api.py . tests/test_api.py from fastapi.testclient import TestClient from http import HTTPStatus def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK Note a utiliza\u00e7\u00e3o do prefixo test nos diret\u00f3rios e arquivos de testes. Isto \u00e9 necess\u00e1rio para que a ferramenta de testes do Python consiga identificar os testes e execut\u00e1-los. Vamos rodar pela primeira vez os testes no nosso projeto. Para n\u00e3o precisar digitar a todo momento os comandos em sua forma extensa poetry run <comando> vamos ativar nosso ambiente virtual com o comando poetry shell . python -m pytest tests/ \ud83d\ude31 Nossa! Ocorreu um erro! $ python -m pytest tests/ ======================================================================================= test session starts ======================================================================================= platform linux -- Python 3.9.7, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: /home/cassiobotaro/Projects/tutorial-pybr collected 1 item tests/test_api.py F [100%] ============================================================================================ FAILURES ============================================================================================= __________________________________________________________ test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ___________________________________________________________ def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200(): > cliente = TestClient(app) E NameError: name 'app' is not defined tests/test_api.py:6: NameError ===================================================================================== short test summary info ===================================================================================== FAILED tests/test_api.py::test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 - NameError: name 'app' is not defined ======================================================================================== 1 failed in 0.23s ======================================================================================== O teste falha pois ainda n\u00e3o temos a nossa aplica\u00e7\u00e3o. A primeira coisa que precisamos fazer \u00e9 criar um diret\u00f3rio onde colocaremos nossos c\u00f3digos. vamos chama-lo de api_pedidos . Dentro dele criamos um novo arquivo api_pedidos/api.py , e neste arquivo vamos iniciar uma aplica\u00e7\u00e3o da seguinte maneira. api_pedidos/api.py from fastapi import FastAPI app = FastAPI () Nosso diret\u00f3rio ficar\u00e1 da seguinte maneira: . \u251c\u2500\u2500 api_pedidos \u2502 \u2514\u2500\u2500 api.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_api.py Agora vamos voltar ao arquivo tests/test_api.py e adicionamos a seguinte linha. tests/test_api.py from api_pedidos.api import app Rode novamente os testes. python -m pytest tests/ \u274c Os testes continuam falhando! Agora temos nossa aplica\u00e7\u00e3o, mas nosso endpoint ainda n\u00e3o foi criado. No arquivo api_pedidos/api.py vamos criar o endpoint /healthcheck : api_pedidos/api.py @app . get ( \"/healthcheck\" ) async def healthcheck (): return Rode novamente os testes. python -m pytest \u2714\ufe0f Legal! Temos um teste funcionando! Nossa aplica\u00e7\u00e3o est\u00e1 retornando o c\u00f3digo de status 200 OK, ainda que a funcionalidade completa n\u00e3o esteja pronta. \ud83d\udc76 Damos o nome de baby step , esta maneira de construir uma aplica\u00e7\u00e3o dando pequenos passos de cada vez. Nosso recurso deve ter o formato json , que \u00e9 um formato textual estruturado, bem simples e leve para troca de informa\u00e7\u00f5es. Mas como checamos isto? Vamos escrever um novo teste! tests/test_api.py def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" Rode os testes novamente. Caso esque\u00e7a o comando, volte um pouco atr\u00e1s e copie. \ud83d\udc40 O novo teste est\u00e1 passando ?!?! Acontece que por padr\u00e3o, o fastapi j\u00e1 define que o formato ser\u00e1 \"json\". Normalmente, queremos que testes falhem, por\u00e9m este teste pode ser \u00fatil como documenta\u00e7\u00e3o do seu recurso. Vamos deixa-lo e vamos seguir em frente, mas agora tentando escrever um teste que realmente falhe. Quando verificar integridade o retorno deve possuir o seguinte formato: { \"status\" : \"ok\" } Assim se precisarmos adicionar mais detalhes neste endpoint podemos adicionar novas chaves a esta estrutura. Estes detalhes podem envolver o estado da conex\u00e3o com o banco de dados. tests/test_api.py def test_quando_verificar_integridade_deve_conter_informacoes (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" } Rode novamente os testes. \u274c O teste falha e isto \u00e9 bom! Vamos continuar nosso ciclo e corrigir o c\u00f3digo. api_pedidos/api.py @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } \u2714\ufe0f Aew! Testes est\u00e3o passando novamente! \ud83d\udea6 Perceberam que estamos guiando o nosso desenvolvimento a partir dos testes? Pouco a pouco temos a funcionalidade de listagem sendo desenhada. Neste passo os arquivos devem estar da seguinte maneira: api_pedidos/api.py from fastapi import FastAPI app = FastAPI () @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } tests/test_api.py from fastapi.testclient import TestClient from http import HTTPStatus from api_pedidos.api import app def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } Os testes est\u00e3o funcionando? Parab\u00e9ns! \ud83d\udc4f\ud83d\udc4f \ud83d\udc4f Agora vamos refatorar o c\u00f3digo. \ud83e\uddd9 Refatorando o c\u00f3digo Se reparar bem, estamos repetindo a seguinte linha de c\u00f3digo tr\u00eas vezes. client = TestClient(app) Vamos utilizar uma fixture (\u00e9 um ambiente usado para testar consistentemente algum item) para criar um cliente. tests/test_api.py from http import HTTPStatus import pytest from api_pedidos.api import app from fastapi.testclient import TestClient @pytest . fixture def cliente (): return TestClient ( app ) def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } Ap\u00f3s esta mudan\u00e7a, os testes devem continuar passando. \ud83d\udd27 Testando manualmente Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Voil\u00e1, sua aplica\u00e7\u00e3o est\u00e1 no ar. Vamos utilizar a ferramenta httpie para testar a aplica\u00e7\u00e3o. Execute o seguinte comando: http :8000/healthcheck Info Como adicionamos a op\u00e7\u00e3o --reload , cada vez que modificamos o c\u00f3digo, o resultado \u00e9 modificado tamb\u00e9m, sem precisar desligar e rodar de novo a aplica\u00e7\u00e3o. \ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/ tests/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois diret\u00f3rios n\u00e3o rastreados e precisamos avisar ao controle de vers\u00e3o para monitora-los. git add api_pedidos tests \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adicionando healthcheck\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Parab\u00e9ns! A aplica\u00e7\u00e3o est\u00e1 tomando forma! \ud83c\udf89 Podemos marcar como pronto as seguintes tarefas: Deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis Deve prover um endpoint que indique a sa\u00fade do sistema O sistema deve apresentar testes (Acabamos cumprindo uma tarefa a mais!) \ud83d\udc02 Uma API robusta prov\u00ea maneiras de verificar sua integridade.","title":"\ud83d\udc4b Ol\u00e1 API"},{"location":"ola_api/#ola-api","text":"","title":"\ud83d\udc4b Ol\u00e1 API"},{"location":"ola_api/#escrevendo-codigo","text":"\u00c9 chegada a t\u00e3o esperada hora de escrevermos c\u00f3digo, por\u00e9m, como aprendemos que podemos ser guiados por testes para ajudar a concep\u00e7\u00e3o da arquitetura do nosso programa, faremos as coisas um pouco diferente. Utilizaremos os ciclos do TDD para nos auxiliarem e assim garantiremos uma qualidade de c\u00f3digo ao final. Est\u00e3o lembrados o que \u00e9 a nossa aplica\u00e7\u00e3o? Caso n\u00e3o se recorde leia o nosso planejamento novamente. Acho que podemos iniciar com os dois requisitos listados abaixo: Deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis Deve prover um endpoint que indique a sa\u00fade do sistema Mas como fazer isto se n\u00e3o temos nem mesmo uma aplica\u00e7\u00e3o ainda? Por onde come\u00e7o? Inicie criando um diret\u00f3rio com o nome tests , onde colocaremos os testes do nosso programa. L\u00e1 dentro, crie um arquivo com nome test_api.py que deve ficar da seguinte maneira: . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_api.py Agora vamos escrever nosso primeiro teste! Info O c\u00f3digo est\u00e1 escrito em portugu\u00eas para ajudar na did\u00e1tica. Para indicar a integridade do nosso sistema, vamos ter um endpoint /healthcheck , que ao receber um requisi\u00e7\u00e3o, deve retornar o c\u00f3digo de status 200 OK e este ser\u00e1 nosso primeiro teste. Traduzindo em um teste automatizado, vamos escrever o seguinte c\u00f3digo no arquivo tests/test_api.py . tests/test_api.py from fastapi.testclient import TestClient from http import HTTPStatus def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK Note a utiliza\u00e7\u00e3o do prefixo test nos diret\u00f3rios e arquivos de testes. Isto \u00e9 necess\u00e1rio para que a ferramenta de testes do Python consiga identificar os testes e execut\u00e1-los. Vamos rodar pela primeira vez os testes no nosso projeto. Para n\u00e3o precisar digitar a todo momento os comandos em sua forma extensa poetry run <comando> vamos ativar nosso ambiente virtual com o comando poetry shell . python -m pytest tests/ \ud83d\ude31 Nossa! Ocorreu um erro! $ python -m pytest tests/ ======================================================================================= test session starts ======================================================================================= platform linux -- Python 3.9.7, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 rootdir: /home/cassiobotaro/Projects/tutorial-pybr collected 1 item tests/test_api.py F [100%] ============================================================================================ FAILURES ============================================================================================= __________________________________________________________ test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ___________________________________________________________ def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200(): > cliente = TestClient(app) E NameError: name 'app' is not defined tests/test_api.py:6: NameError ===================================================================================== short test summary info ===================================================================================== FAILED tests/test_api.py::test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 - NameError: name 'app' is not defined ======================================================================================== 1 failed in 0.23s ======================================================================================== O teste falha pois ainda n\u00e3o temos a nossa aplica\u00e7\u00e3o. A primeira coisa que precisamos fazer \u00e9 criar um diret\u00f3rio onde colocaremos nossos c\u00f3digos. vamos chama-lo de api_pedidos . Dentro dele criamos um novo arquivo api_pedidos/api.py , e neste arquivo vamos iniciar uma aplica\u00e7\u00e3o da seguinte maneira. api_pedidos/api.py from fastapi import FastAPI app = FastAPI () Nosso diret\u00f3rio ficar\u00e1 da seguinte maneira: . \u251c\u2500\u2500 api_pedidos \u2502 \u2514\u2500\u2500 api.py \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u2514\u2500\u2500 tests \u2514\u2500\u2500 test_api.py Agora vamos voltar ao arquivo tests/test_api.py e adicionamos a seguinte linha. tests/test_api.py from api_pedidos.api import app Rode novamente os testes. python -m pytest tests/ \u274c Os testes continuam falhando! Agora temos nossa aplica\u00e7\u00e3o, mas nosso endpoint ainda n\u00e3o foi criado. No arquivo api_pedidos/api.py vamos criar o endpoint /healthcheck : api_pedidos/api.py @app . get ( \"/healthcheck\" ) async def healthcheck (): return Rode novamente os testes. python -m pytest \u2714\ufe0f Legal! Temos um teste funcionando! Nossa aplica\u00e7\u00e3o est\u00e1 retornando o c\u00f3digo de status 200 OK, ainda que a funcionalidade completa n\u00e3o esteja pronta. \ud83d\udc76 Damos o nome de baby step , esta maneira de construir uma aplica\u00e7\u00e3o dando pequenos passos de cada vez. Nosso recurso deve ter o formato json , que \u00e9 um formato textual estruturado, bem simples e leve para troca de informa\u00e7\u00f5es. Mas como checamos isto? Vamos escrever um novo teste! tests/test_api.py def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" Rode os testes novamente. Caso esque\u00e7a o comando, volte um pouco atr\u00e1s e copie. \ud83d\udc40 O novo teste est\u00e1 passando ?!?! Acontece que por padr\u00e3o, o fastapi j\u00e1 define que o formato ser\u00e1 \"json\". Normalmente, queremos que testes falhem, por\u00e9m este teste pode ser \u00fatil como documenta\u00e7\u00e3o do seu recurso. Vamos deixa-lo e vamos seguir em frente, mas agora tentando escrever um teste que realmente falhe. Quando verificar integridade o retorno deve possuir o seguinte formato: { \"status\" : \"ok\" } Assim se precisarmos adicionar mais detalhes neste endpoint podemos adicionar novas chaves a esta estrutura. Estes detalhes podem envolver o estado da conex\u00e3o com o banco de dados. tests/test_api.py def test_quando_verificar_integridade_deve_conter_informacoes (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" } Rode novamente os testes. \u274c O teste falha e isto \u00e9 bom! Vamos continuar nosso ciclo e corrigir o c\u00f3digo. api_pedidos/api.py @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } \u2714\ufe0f Aew! Testes est\u00e3o passando novamente! \ud83d\udea6 Perceberam que estamos guiando o nosso desenvolvimento a partir dos testes? Pouco a pouco temos a funcionalidade de listagem sendo desenhada. Neste passo os arquivos devem estar da seguinte maneira: api_pedidos/api.py from fastapi import FastAPI app = FastAPI () @app . get ( \"/healthcheck\" ) async def healthcheck (): return { \"status\" : \"ok\" } tests/test_api.py from fastapi.testclient import TestClient from http import HTTPStatus from api_pedidos.api import app def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes (): cliente = TestClient ( app ) resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } Os testes est\u00e3o funcionando? Parab\u00e9ns! \ud83d\udc4f\ud83d\udc4f \ud83d\udc4f Agora vamos refatorar o c\u00f3digo.","title":"\u270d\ufe0f Escrevendo c\u00f3digo"},{"location":"ola_api/#refatorando-o-codigo","text":"Se reparar bem, estamos repetindo a seguinte linha de c\u00f3digo tr\u00eas vezes. client = TestClient(app) Vamos utilizar uma fixture (\u00e9 um ambiente usado para testar consistentemente algum item) para criar um cliente. tests/test_api.py from http import HTTPStatus import pytest from api_pedidos.api import app from fastapi.testclient import TestClient @pytest . fixture def cliente (): return TestClient ( app ) def test_quando_verificar_integridade_devo_ter_como_retorno_codigo_de_status_200 ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . status_code == HTTPStatus . OK def test_quando_verificar_integridade_formato_de_retorno_deve_ser_json ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . headers [ \"Content-Type\" ] == \"application/json\" def test_quando_verificar_integridade_deve_conter_informacoes ( cliente ): resposta = cliente . get ( \"/healthcheck\" ) assert resposta . json () == { \"status\" : \"ok\" , } Ap\u00f3s esta mudan\u00e7a, os testes devem continuar passando.","title":"\ud83e\uddd9 Refatorando o c\u00f3digo"},{"location":"ola_api/#testando-manualmente","text":"Para testar nossa aplica\u00e7\u00e3o manualmente, precisamos colocar nossa aplica\u00e7\u00e3o no ar. O comando para isto \u00e9 uvicorn --reload api_pedidos.api:app . Voil\u00e1, sua aplica\u00e7\u00e3o est\u00e1 no ar. Vamos utilizar a ferramenta httpie para testar a aplica\u00e7\u00e3o. Execute o seguinte comando: http :8000/healthcheck Info Como adicionamos a op\u00e7\u00e3o --reload , cada vez que modificamos o c\u00f3digo, o resultado \u00e9 modificado tamb\u00e9m, sem precisar desligar e rodar de novo a aplica\u00e7\u00e3o.","title":"\ud83d\udd27 Testando manualmente"},{"location":"ola_api/#salvando-a-versao-atual-do-codigo","text":"Com tudo terminado, vamos salvar a vers\u00e3o atual do c\u00f3digo. Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) api_pedidos/ tests/ nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois diret\u00f3rios n\u00e3o rastreados e precisamos avisar ao controle de vers\u00e3o para monitora-los. git add api_pedidos tests \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como salva. git commit -m \"Adicionando healthcheck\" \ud83d\udc31 Por fim envie ao github a vers\u00e3o atualizada do projeto. git push Parab\u00e9ns! A aplica\u00e7\u00e3o est\u00e1 tomando forma! \ud83c\udf89 Podemos marcar como pronto as seguintes tarefas: Deve apresentar uma interface que possa ser consumida tanto por um website, tanto por um aplicativo para dispositivos m\u00f3veis Deve prover um endpoint que indique a sa\u00fade do sistema O sistema deve apresentar testes (Acabamos cumprindo uma tarefa a mais!) \ud83d\udc02 Uma API robusta prov\u00ea maneiras de verificar sua integridade.","title":"\ud83d\udcbe Salvando a vers\u00e3o atual do c\u00f3digo"},{"location":"planejando/","text":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido Aviso legal O sistema desenvolvido \u00e9 apenas para fins de treinamento e desenvolvimento das t\u00e9cnicas apresentadas. Aprenda as t\u00e9cnicas e certifique-se que s\u00e3o adequadas para o seu sistema. \ud83d\udecd\ufe0f O que ser\u00e1 desenvolvido? Ser\u00e1 desenvolvido um sistema com objetivo de obter informa\u00e7\u00f5es a respeito de pedidos. Os pedidos ser\u00e3o obtidos atrav\u00e9s de integra\u00e7\u00e3o com um sistema de pedidos externo. Vamos fazer o enriquecimento desta informa\u00e7\u00e3o antes de sua exibi\u00e7\u00e3o e tamb\u00e9m iremos prover alguns dados estat\u00edsticos sobre o pedido. Um pedido possui v\u00e1rios pacotes, cada um deles contendo itens. Este sistema deve seguir as seguintes regras: Deve apresentar uma interface que possa ser consumida tanto por um website, quanto por um aplicativo para dispositivos m\u00f3veis; Deve prover um endpoint que indique a sa\u00fade do sistema; Dado um pedido, retornar os seus itens; Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade; Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos; Dado um pedido (v\u00e1rios itens), enriquecer a informa\u00e7\u00e3o com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m a marca, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto; Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; O sistema deve apresentar testes. \ud83d\ude28 E agora, o que fazer? Por onde come\u00e7o? Vamos escolher nossas ferramentas!","title":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido"},{"location":"planejando/#planejando-o-que-sera-desenvolvido","text":"Aviso legal O sistema desenvolvido \u00e9 apenas para fins de treinamento e desenvolvimento das t\u00e9cnicas apresentadas. Aprenda as t\u00e9cnicas e certifique-se que s\u00e3o adequadas para o seu sistema.","title":"\ud83d\udcad Planejando o que ser\u00e1 desenvolvido"},{"location":"planejando/#o-que-sera-desenvolvido","text":"Ser\u00e1 desenvolvido um sistema com objetivo de obter informa\u00e7\u00f5es a respeito de pedidos. Os pedidos ser\u00e3o obtidos atrav\u00e9s de integra\u00e7\u00e3o com um sistema de pedidos externo. Vamos fazer o enriquecimento desta informa\u00e7\u00e3o antes de sua exibi\u00e7\u00e3o e tamb\u00e9m iremos prover alguns dados estat\u00edsticos sobre o pedido. Um pedido possui v\u00e1rios pacotes, cada um deles contendo itens. Este sistema deve seguir as seguintes regras: Deve apresentar uma interface que possa ser consumida tanto por um website, quanto por um aplicativo para dispositivos m\u00f3veis; Deve prover um endpoint que indique a sa\u00fade do sistema; Dado um pedido, retornar os seus itens; Os itens de um pedido devem conter um identificador (sku), uma descri\u00e7\u00e3o, uma imagem, uma refer\u00eancia e a quantidade; Exibir um relat\u00f3rio com o total de m\u00e9todos de pagamento utilizados nos \u00faltimos 30 pedidos; Dado um pedido (v\u00e1rios itens), enriquecer a informa\u00e7\u00e3o com as informa\u00e7\u00f5es de gtin (global trade item number). Deve ser retornado tamb\u00e9m a marca, descri\u00e7\u00e3o e identifica\u00e7\u00e3o do produto; Como ser\u00e1 consumido por terceiros deve apresentar boa documenta\u00e7\u00e3o; O sistema deve estar preparado para receber novas funcionalidades, garantindo qualidade a cada entrega; O sistema deve apresentar testes. \ud83d\ude28 E agora, o que fazer? Por onde come\u00e7o? Vamos escolher nossas ferramentas!","title":"\ud83d\udecd\ufe0f O que ser\u00e1 desenvolvido?"},{"location":"projeto/","text":"\ud83d\udcd0 Iniciando o projeto O primeiro passo para a constru\u00e7\u00e3o do nosso projeto \u00e9 iniciar seu reposit\u00f3rio e adicionar suas depend\u00eancias. Faremos isto utilizando o Github , que \u00e9 uma plataforma gratuita, muito conhecida e que ir\u00e1 nos ajudar com algumas integra\u00e7\u00f5es no futuro. Mas por que iniciaremos criando o projeto l\u00e1 e n\u00e3o no pr\u00f3prio computador? Queremos contar desde o in\u00edcio do projeto com uma c\u00f3pia remota, garantindo assim que nosso trabalho n\u00e3o ser\u00e1 perdido e que estar\u00e1 compartilhado. A cada passo dado vamos consolidando o que temos no momento. \ud83d\udea7 Come\u00e7ando a tirar do papel o projeto Abra seu navegador, e acesse o seguinte endere\u00e7o . Crie uma conta se ainda n\u00e3o tiver. Aperte o bot\u00e3o novo_reposit\u00f3rio. Preencha os campos como visto na imagem abaixo. Agora fa\u00e7a um \"clone\" do seu reposit\u00f3rio. git clone https://github.com/cassiobotaro/tutorial-pybr.git git clone \u00e9 um comando para criar uma c\u00f3pia dos arquivos e suas vers\u00f5es. Pode ser feito para trazer uma c\u00f3pia do reposit\u00f3rio do servidor para o computador local. Warning Os comandos abaixo devem ser modificados com seu email e nome de usu\u00e1rio do github. USUARIO deve ser modificado para seu usu\u00e1rio do github e EMAIL substituido pelo email utilizado no github. $ git config --local user.email EMAIL $ git config --local user.name USUARIO \"Voil\u00e0\", j\u00e1 temos o projeto iniciado. Navegue at\u00e9 o diret\u00f3rio onde foi executado o comando de clone do projeto. Prossiga com a instala\u00e7\u00e3o das bibliotecas que ser\u00e3o utilizadas no projeto. \ud83d\udccf Iniciando um projeto Python Agora com o reposit\u00f3rio criado, vamos come\u00e7ar a criar um projeto Python. Execute o comando: poetry init -n Info A op\u00e7\u00e3o -n evita que o poetry fique perguntando algumas op\u00e7\u00f5es do projeto. Considere remove-la em pr\u00f3ximos projetos. Este comando iniciliza um arquivo pyproject.toml de configura\u00e7\u00e3o do projeto. Com o projeto iniciado, vamos instalar as depend\u00eancias. \ud83d\udcda Bibliotecas e utilit\u00e1rios Chegou a hora de instalar algumas bibliotecas e utilit\u00e1rios que nos auxiliar\u00e3o na cria\u00e7\u00e3o do nosso sistema web, na realiza\u00e7\u00e3o de testes unit\u00e1rios e testes manuais. \ud83d\udda5\ufe0f O ambiente virtual Como estamos utilizando o poetry, todas as bibliotecas ser\u00e3o instaladas em um ambiente virtual isolado, exclusivo para este projeto. Na primeira vez que o comando add for utilizado, o ambiente virtual ser\u00e1 criado. Veja mais detalhes sobre ambientes virtuais aqui . \u26a1 FastAPI O que \u00e9? O fastapi \u00e9 uma ferramenta para desenvolvimento web, possui alta performance, f\u00e1cil de aprender, r\u00e1pida para escrever c\u00f3digo e pronta para colocar o c\u00f3digo no ar. Para que serve? Serve para escrevermos nossa aplica\u00e7\u00e3o web de forma r\u00e1pida e customiz\u00e1vel. Possui fun\u00e7\u00f5es que auxiliam opera\u00e7\u00f5es como roteamento, tratamento de requisi\u00e7\u00f5es, renderiza\u00e7\u00e3o de conte\u00fado, gerenciamento de sess\u00e3o e cookies, assim como v\u00e1rias outras que s\u00e3o t\u00edpicas da web. Como instalar? Execute o comando: poetry add fastapi Vamos verificar se deu tudo certo? Execute poetry run python -c \"import fastapi\" Nenhum erro deve ocorrer. \ud83e\udd8b Httpx O que \u00e9? Httpx \u00e9 um cliente HTTP completo, com suporte ao protocolo HTTP/2 e prov\u00ea interface de programa\u00e7\u00e3o s\u00edncrona e ass\u00edncrona. Para que serve? Utilizaremos para fazer a integra\u00e7\u00e3o com servi\u00e7os externos. Suas fun\u00e7\u00f5es facilitam a cria\u00e7\u00e3o de requisi\u00e7\u00f5es HTTP. Como instalar? Execute o comando: poetry add httpx Vamos verificar se deu tudo certo? Execute o seguinte comando: poetry run python -c \"import httpx\" Nenhum erro deve ocorrer. \ud83d\udd17 Httpie O que \u00e9? HTTPie \u00e9 um cliente HTTP por linha de comando. Seu objetivo \u00e9 transformar a intera\u00e7\u00e3o com servi\u00e7os web o mais humano poss\u00edvel. Para que serve? Diversos momentos do curso, teremos de testar manualmente se nosso sistema est\u00e1 funcionando, ainda que possua testes automatizados. Tamb\u00e9m ser\u00e1 utilizado para explorar as API's que iremos integrar. Esta ferramenta ajuda a fazer estes testes de uma maneira mais simples. Como instalar? Execute o comando: poetry add httpie --dev Info Utilizamos a op\u00e7\u00e3o --dev pois o httpie \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software. Vamos verificar se deu tudo certo? Execute o seguinte comando: poetry run http --version Tip O comando \u00e9 http e n\u00e3o httpie. A sa\u00edda deve ser similar a: 2.5.0 \ud83e\udd84 Uvicorn O que \u00e9? O uvicorn \u00e9 um servidor de aplica\u00e7\u00e3o com suporte a frameworks ass\u00edncronos. Para que serve? O uvicorn serve para rodar a nossa aplica\u00e7\u00e3o, tanto na nossa m\u00e1quina quanto em um servidor na internet. Como instalar? Execute o comando: poetry add uvicorn Vamos verificar se deu tudo certo? Execute o seguinte comando: poetry run uvicorn --version A sa\u00edda deve ser similar a: Running uvicorn 0.15.0 with CPython 3.9.7 on Linux \ud83d\udea6 Pytest O que \u00e9? O framework pytest \u00e9 f\u00e1cil para escrever teste simples, ainda escala para suportar testes funcionais complexos para aplica\u00e7\u00f5es e bibliotecas. Para que serve? J\u00e1 dizia Michael C. Feathers, \"Um c\u00f3digo sem testes, \u00e9 um c\u00f3digo ruim. N\u00e3o importa qu\u00e3o bem ele foi escrito\". Vamos ent\u00e3o instalar o pytest, que \u00e9 uma ferramenta que auxilia na execu\u00e7\u00e3o de testes. Como instalar? Execute o comando: poetry add pytest --dev Info Utilizamos a op\u00e7\u00e3o --dev pois o pytest \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software. Vamos verificar se deu tudo certo? Execute o seguinte comando: poetry run pytest --version A sa\u00edda deve ser similar a: pytest 6.2.5 \ud83d\udcbe Salvando o momento atual do nosso projeto Neste momento seu diret\u00f3rio deve estar assim: . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 README.md Instalado as depend\u00eancias, vamos consolidar uma primeira vers\u00e3o do nosso projeto com o nosso andamento? Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) poetry.lock pyproject.toml nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois arquivos n\u00e3o rastreados, precisamos avisar ao controle de vers\u00e3o que monitore estes arquivos. git add pyproject.toml poetry.lock \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona as depend\u00eancias do projeto\" \ud83d\udc31 Por fim, envie ao github a vers\u00e3o atualizada do projeto. git push \ud83c\udf70 Entusiasmados a come\u00e7ar a escrever sua aplica\u00e7\u00e3o? Agora que temos todo o ambiente configurado, j\u00e1 estamos bem pr\u00f3ximo disso. Vamos ao pr\u00f3ximo passo!","title":"\ud83d\udcd0 Iniciando o projeto"},{"location":"projeto/#iniciando-o-projeto","text":"O primeiro passo para a constru\u00e7\u00e3o do nosso projeto \u00e9 iniciar seu reposit\u00f3rio e adicionar suas depend\u00eancias. Faremos isto utilizando o Github , que \u00e9 uma plataforma gratuita, muito conhecida e que ir\u00e1 nos ajudar com algumas integra\u00e7\u00f5es no futuro. Mas por que iniciaremos criando o projeto l\u00e1 e n\u00e3o no pr\u00f3prio computador? Queremos contar desde o in\u00edcio do projeto com uma c\u00f3pia remota, garantindo assim que nosso trabalho n\u00e3o ser\u00e1 perdido e que estar\u00e1 compartilhado. A cada passo dado vamos consolidando o que temos no momento.","title":"\ud83d\udcd0 Iniciando o projeto"},{"location":"projeto/#comecando-a-tirar-do-papel-o-projeto","text":"Abra seu navegador, e acesse o seguinte endere\u00e7o . Crie uma conta se ainda n\u00e3o tiver. Aperte o bot\u00e3o novo_reposit\u00f3rio. Preencha os campos como visto na imagem abaixo. Agora fa\u00e7a um \"clone\" do seu reposit\u00f3rio. git clone https://github.com/cassiobotaro/tutorial-pybr.git git clone \u00e9 um comando para criar uma c\u00f3pia dos arquivos e suas vers\u00f5es. Pode ser feito para trazer uma c\u00f3pia do reposit\u00f3rio do servidor para o computador local. Warning Os comandos abaixo devem ser modificados com seu email e nome de usu\u00e1rio do github. USUARIO deve ser modificado para seu usu\u00e1rio do github e EMAIL substituido pelo email utilizado no github. $ git config --local user.email EMAIL $ git config --local user.name USUARIO \"Voil\u00e0\", j\u00e1 temos o projeto iniciado. Navegue at\u00e9 o diret\u00f3rio onde foi executado o comando de clone do projeto. Prossiga com a instala\u00e7\u00e3o das bibliotecas que ser\u00e3o utilizadas no projeto.","title":"\ud83d\udea7 Come\u00e7ando a tirar do papel o projeto"},{"location":"projeto/#iniciando-um-projeto-python","text":"Agora com o reposit\u00f3rio criado, vamos come\u00e7ar a criar um projeto Python. Execute o comando: poetry init -n Info A op\u00e7\u00e3o -n evita que o poetry fique perguntando algumas op\u00e7\u00f5es do projeto. Considere remove-la em pr\u00f3ximos projetos. Este comando iniciliza um arquivo pyproject.toml de configura\u00e7\u00e3o do projeto. Com o projeto iniciado, vamos instalar as depend\u00eancias.","title":"\ud83d\udccf Iniciando um projeto Python"},{"location":"projeto/#bibliotecas-e-utilitarios","text":"Chegou a hora de instalar algumas bibliotecas e utilit\u00e1rios que nos auxiliar\u00e3o na cria\u00e7\u00e3o do nosso sistema web, na realiza\u00e7\u00e3o de testes unit\u00e1rios e testes manuais. \ud83d\udda5\ufe0f O ambiente virtual Como estamos utilizando o poetry, todas as bibliotecas ser\u00e3o instaladas em um ambiente virtual isolado, exclusivo para este projeto. Na primeira vez que o comando add for utilizado, o ambiente virtual ser\u00e1 criado. Veja mais detalhes sobre ambientes virtuais aqui .","title":"\ud83d\udcda Bibliotecas e utilit\u00e1rios"},{"location":"projeto/#fastapi","text":"","title":"\u26a1 FastAPI"},{"location":"projeto/#o-que-e","text":"O fastapi \u00e9 uma ferramenta para desenvolvimento web, possui alta performance, f\u00e1cil de aprender, r\u00e1pida para escrever c\u00f3digo e pronta para colocar o c\u00f3digo no ar.","title":"O que \u00e9?"},{"location":"projeto/#para-que-serve","text":"Serve para escrevermos nossa aplica\u00e7\u00e3o web de forma r\u00e1pida e customiz\u00e1vel. Possui fun\u00e7\u00f5es que auxiliam opera\u00e7\u00f5es como roteamento, tratamento de requisi\u00e7\u00f5es, renderiza\u00e7\u00e3o de conte\u00fado, gerenciamento de sess\u00e3o e cookies, assim como v\u00e1rias outras que s\u00e3o t\u00edpicas da web.","title":"Para que serve?"},{"location":"projeto/#como-instalar","text":"Execute o comando: poetry add fastapi","title":"Como instalar?"},{"location":"projeto/#vamos-verificar-se-deu-tudo-certo","text":"Execute poetry run python -c \"import fastapi\" Nenhum erro deve ocorrer.","title":"Vamos verificar se deu tudo certo?"},{"location":"projeto/#httpx","text":"","title":"\ud83e\udd8b Httpx"},{"location":"projeto/#o-que-e_1","text":"Httpx \u00e9 um cliente HTTP completo, com suporte ao protocolo HTTP/2 e prov\u00ea interface de programa\u00e7\u00e3o s\u00edncrona e ass\u00edncrona.","title":"O que \u00e9?"},{"location":"projeto/#para-que-serve_1","text":"Utilizaremos para fazer a integra\u00e7\u00e3o com servi\u00e7os externos. Suas fun\u00e7\u00f5es facilitam a cria\u00e7\u00e3o de requisi\u00e7\u00f5es HTTP.","title":"Para que serve?"},{"location":"projeto/#como-instalar_1","text":"Execute o comando: poetry add httpx","title":"Como instalar?"},{"location":"projeto/#vamos-verificar-se-deu-tudo-certo_1","text":"Execute o seguinte comando: poetry run python -c \"import httpx\" Nenhum erro deve ocorrer.","title":"Vamos verificar se deu tudo certo?"},{"location":"projeto/#httpie","text":"","title":"\ud83d\udd17 Httpie"},{"location":"projeto/#o-que-e_2","text":"HTTPie \u00e9 um cliente HTTP por linha de comando. Seu objetivo \u00e9 transformar a intera\u00e7\u00e3o com servi\u00e7os web o mais humano poss\u00edvel.","title":"O que \u00e9?"},{"location":"projeto/#para-que-serve_2","text":"Diversos momentos do curso, teremos de testar manualmente se nosso sistema est\u00e1 funcionando, ainda que possua testes automatizados. Tamb\u00e9m ser\u00e1 utilizado para explorar as API's que iremos integrar. Esta ferramenta ajuda a fazer estes testes de uma maneira mais simples.","title":"Para que serve?"},{"location":"projeto/#como-instalar_2","text":"Execute o comando: poetry add httpie --dev Info Utilizamos a op\u00e7\u00e3o --dev pois o httpie \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software.","title":"Como instalar?"},{"location":"projeto/#vamos-verificar-se-deu-tudo-certo_2","text":"Execute o seguinte comando: poetry run http --version Tip O comando \u00e9 http e n\u00e3o httpie. A sa\u00edda deve ser similar a: 2.5.0","title":"Vamos verificar se deu tudo certo?"},{"location":"projeto/#uvicorn","text":"","title":"\ud83e\udd84 Uvicorn"},{"location":"projeto/#o-que-e_3","text":"O uvicorn \u00e9 um servidor de aplica\u00e7\u00e3o com suporte a frameworks ass\u00edncronos.","title":"O que \u00e9?"},{"location":"projeto/#para-que-serve_3","text":"O uvicorn serve para rodar a nossa aplica\u00e7\u00e3o, tanto na nossa m\u00e1quina quanto em um servidor na internet.","title":"Para que serve?"},{"location":"projeto/#como-instalar_3","text":"Execute o comando: poetry add uvicorn","title":"Como instalar?"},{"location":"projeto/#vamos-verificar-se-deu-tudo-certo_3","text":"Execute o seguinte comando: poetry run uvicorn --version A sa\u00edda deve ser similar a: Running uvicorn 0.15.0 with CPython 3.9.7 on Linux","title":"Vamos verificar se deu tudo certo?"},{"location":"projeto/#pytest","text":"","title":"\ud83d\udea6 Pytest"},{"location":"projeto/#o-que-e_4","text":"O framework pytest \u00e9 f\u00e1cil para escrever teste simples, ainda escala para suportar testes funcionais complexos para aplica\u00e7\u00f5es e bibliotecas.","title":"O que \u00e9?"},{"location":"projeto/#para-que-serve_4","text":"J\u00e1 dizia Michael C. Feathers, \"Um c\u00f3digo sem testes, \u00e9 um c\u00f3digo ruim. N\u00e3o importa qu\u00e3o bem ele foi escrito\". Vamos ent\u00e3o instalar o pytest, que \u00e9 uma ferramenta que auxilia na execu\u00e7\u00e3o de testes.","title":"Para que serve?"},{"location":"projeto/#como-instalar_4","text":"Execute o comando: poetry add pytest --dev Info Utilizamos a op\u00e7\u00e3o --dev pois o pytest \u00e9 um pacote necess\u00e1rio somente durante o desenvolvimento e n\u00e3o durante a execu\u00e7\u00e3o do software.","title":"Como instalar?"},{"location":"projeto/#vamos-verificar-se-deu-tudo-certo_4","text":"Execute o seguinte comando: poetry run pytest --version A sa\u00edda deve ser similar a: pytest 6.2.5","title":"Vamos verificar se deu tudo certo?"},{"location":"projeto/#salvando-o-momento-atual-do-nosso-projeto","text":"Neste momento seu diret\u00f3rio deve estar assim: . \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 README.md Instalado as depend\u00eancias, vamos consolidar uma primeira vers\u00e3o do nosso projeto com o nosso andamento? Primeiro passo \u00e9 checar o que foi feito at\u00e9 agora: $ git status On branch main Your branch is up to date with 'origin/main' . Untracked files: ( use \"git add <file>...\" to include in what will be committed ) poetry.lock pyproject.toml nothing added to commit but untracked files present ( use \"git add\" to track ) Vemos dois arquivos n\u00e3o rastreados, precisamos avisar ao controle de vers\u00e3o que monitore estes arquivos. git add pyproject.toml poetry.lock \ud83d\udcbe Agora vamos marcar esta vers\u00e3o como consolidada. git commit -m \"Adiciona as depend\u00eancias do projeto\" \ud83d\udc31 Por fim, envie ao github a vers\u00e3o atualizada do projeto. git push \ud83c\udf70 Entusiasmados a come\u00e7ar a escrever sua aplica\u00e7\u00e3o? Agora que temos todo o ambiente configurado, j\u00e1 estamos bem pr\u00f3ximo disso. Vamos ao pr\u00f3ximo passo!","title":"\ud83d\udcbe Salvando o momento atual do nosso projeto"},{"location":"pyenv/","text":"\ud83c\udfed Pyenv O que \u00e9? Pyenv \u00e9 um ambiente de desenvolvimento de software que permite ao usu\u00e1rio escolher qual vers\u00e3o do python que deseja utilizar. Para que serve? O pyenv \u00e9 uma ferramenta que nos ajuda a gerenciar m\u00faltiplas vers\u00f5es de python instaladas na mesma m\u00e1quina e ajuda a n\u00e3o ter problemas com vers\u00f5es incompat\u00edveis entre si. Como instalar? O pyenv pode ser baixado como um reposit\u00f3rio no github: git clone https://github.com/pyenv/pyenv.git ~/.pyenv Inclua no final do seu arquivo de configura\u00e7\u00e3o do bash ou similar (.bashrc, .zshrc, etc) o seguinte: export PYENV_ROOT=\"$HOME/.pyenv\" export PATH=\"$PYENV_ROOT/bin:$PATH\" eval \"$(pyenv init --path)\" eval \"$(pyenv init -)\" Reinicie seu shell para que as mudan\u00e7as tenham efeito exec $SHELL Vamos verificar se deu tudo certo? Abra um terminal e digite: pyenv --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: pyenv 2.0.7-32-gc81a2810 Como usar? Tip \u00c9 recomendado antes de instalar uma vers\u00e3o que se instale as depend\u00eancias do python de acordo com o sistema operacional https://github.com/pyenv/pyenv/wiki#suggested-build-environment Para instalar uma vers\u00e3o espec\u00edfica do python basta digitar: pyenv install <vers\u00e3o> Para definir aquela vers\u00e3o como padr\u00e3o basta digitar: pyenv global <vers\u00e3o> ou caso queira definir somente para um projeto: pyenv local <vers\u00e3o> Para verificar as vers\u00f5es instaladas: pyenv versions \u21a9\ufe0f Voltar","title":"Pyenv"},{"location":"pyenv/#pyenv","text":"","title":"\ud83c\udfed Pyenv"},{"location":"pyenv/#o-que-e","text":"Pyenv \u00e9 um ambiente de desenvolvimento de software que permite ao usu\u00e1rio escolher qual vers\u00e3o do python que deseja utilizar.","title":"O que \u00e9?"},{"location":"pyenv/#para-que-serve","text":"O pyenv \u00e9 uma ferramenta que nos ajuda a gerenciar m\u00faltiplas vers\u00f5es de python instaladas na mesma m\u00e1quina e ajuda a n\u00e3o ter problemas com vers\u00f5es incompat\u00edveis entre si.","title":"Para que serve?"},{"location":"pyenv/#como-instalar","text":"O pyenv pode ser baixado como um reposit\u00f3rio no github: git clone https://github.com/pyenv/pyenv.git ~/.pyenv Inclua no final do seu arquivo de configura\u00e7\u00e3o do bash ou similar (.bashrc, .zshrc, etc) o seguinte: export PYENV_ROOT=\"$HOME/.pyenv\" export PATH=\"$PYENV_ROOT/bin:$PATH\" eval \"$(pyenv init --path)\" eval \"$(pyenv init -)\" Reinicie seu shell para que as mudan\u00e7as tenham efeito exec $SHELL","title":"Como instalar?"},{"location":"pyenv/#vamos-verificar-se-deu-tudo-certo","text":"Abra um terminal e digite: pyenv --version A sa\u00edda dever\u00e1 ser similar a apresentada abaixo: pyenv 2.0.7-32-gc81a2810","title":"Vamos verificar se deu tudo certo?"},{"location":"pyenv/#como-usar","text":"Tip \u00c9 recomendado antes de instalar uma vers\u00e3o que se instale as depend\u00eancias do python de acordo com o sistema operacional https://github.com/pyenv/pyenv/wiki#suggested-build-environment Para instalar uma vers\u00e3o espec\u00edfica do python basta digitar: pyenv install <vers\u00e3o> Para definir aquela vers\u00e3o como padr\u00e3o basta digitar: pyenv global <vers\u00e3o> ou caso queira definir somente para um projeto: pyenv local <vers\u00e3o> Para verificar as vers\u00f5es instaladas: pyenv versions \u21a9\ufe0f Voltar","title":"Como usar?"},{"location":"referencias/","text":"\ud83d\udcd1 Refer\u00eancias e Dicas \ud83d\udcfd\ufe0f V\u00eddeos https://www.youtube.com/c/ArjanCodes https://www.youtube.com/c/Dunossauro https://www.youtube.com/c/ContinuousDelivery https://www.youtube.com/c/EximiaCo \ud83d\udcda Livros https://www.amazon.com.br/Fluent-Python-Concise-Effective-Programming/dp/1492056359 https://www.amazon.com.br/Robust-Python-Write-Clean-Maintainable/dp/1098100662 \ud83c\udf10 Sites https://calmcode.io/ https://fastapi.tiangolo.com/tutorial/ \ud83d\udcdd Artigos https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm https://wssilva-willian.medium.com/design-de-api-rest-9807a5b16c9f Obrigado Jesus por este easter egg! \ud83e\udd5a jjjlbhghorpbzjngpui92A_83dzJOj \u2b06\ufe0f\u2b06\ufe0f\u2b07\ufe0f\u2b07\ufe0f\u2b05\ufe0f\u27a1\ufe0f\u2b05\ufe0f\u27a1\ufe0f\ud83c\udd70\ufe0f\ud83c\udd71\ufe0f","title":"\ud83d\udcd1 Refer\u00eancias e Dicas"},{"location":"referencias/#referencias-e-dicas","text":"","title":"\ud83d\udcd1 Refer\u00eancias e Dicas"},{"location":"referencias/#videos","text":"https://www.youtube.com/c/ArjanCodes https://www.youtube.com/c/Dunossauro https://www.youtube.com/c/ContinuousDelivery https://www.youtube.com/c/EximiaCo","title":"\ud83d\udcfd\ufe0f V\u00eddeos"},{"location":"referencias/#livros","text":"https://www.amazon.com.br/Fluent-Python-Concise-Effective-Programming/dp/1492056359 https://www.amazon.com.br/Robust-Python-Write-Clean-Maintainable/dp/1098100662","title":"\ud83d\udcda Livros"},{"location":"referencias/#sites","text":"https://calmcode.io/ https://fastapi.tiangolo.com/tutorial/","title":"\ud83c\udf10 Sites"},{"location":"referencias/#artigos","text":"https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm https://wssilva-willian.medium.com/design-de-api-rest-9807a5b16c9f Obrigado Jesus por este easter egg! \ud83e\udd5a jjjlbhghorpbzjngpui92A_83dzJOj \u2b06\ufe0f\u2b06\ufe0f\u2b07\ufe0f\u2b07\ufe0f\u2b05\ufe0f\u27a1\ufe0f\u2b05\ufe0f\u27a1\ufe0f\ud83c\udd70\ufe0f\ud83c\udd71\ufe0f","title":"\ud83d\udcdd Artigos"},{"location":"tdd/","text":"\ud83d\udc10 Desenvolvimento guiado por testes (TDD) Testes automatizados Talvez tenha chegado aqui sem conhecimento sobre testes automatizados, por isso vamos a uma breve explica\u00e7\u00e3o. \u00c9 muito comum enquanto estamos desenvolvendo, testarmos manualmente as funcionalidades que estamos implementando, mas o que pode ocorrer se eu me esquecer de testar alguma funcionalidade? Por isso escrevemos c\u00f3digo para testar o c\u00f3digo das nossas funcionalidades. Automatizar testes \u00e9 uma maneira de agilizar nosso processo de desenvolvimento, garantindo que novas funcionalidades n\u00e3o impactam sobre as antigas. Um exemplo de teste automatizado. c\u00f3digo def \u00e9_impar ( numero ): 'Retorna True se um n\u00famero \u00e9 verdadeiro, sen\u00e3o False.' return numero % 2 != 0 teste def test_quando_entrada_\u00e9_tr\u00eas_retorna_verdadeiro (): assert \u00e9_impar ( 3 ) is True def test_quando_entrada_\u00e9_dois_retorna_falso (): assert \u00e9_impar ( 2 ) is False \u00c9 importante notar que nos testes eu tento cobrir todas as possibilidades de resultado daquela fun\u00e7\u00e3o, como no exemplo que testo a fun\u00e7\u00e3o para valores pares e \u00edmpares. O que \u00e9 TDD? Desenvolvimento guiado por testes(Test Driven Development) \u00e9 uma t\u00e9cnica de desenvolvimento de software que baseia em um ciclo curto de repeti\u00e7\u00f5es: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Ent\u00e3o, \u00e9 produzido c\u00f3digo que possa ser validado pelo teste para posteriormente o c\u00f3digo ser refatorado para um c\u00f3digo sob padr\u00f5es aceit\u00e1veis. Mas por que TDD? Escrever testes antes do c\u00f3digo ajuda no planejamento da arquitetura da aplica\u00e7\u00e3o, e os testes podem ser um guia de como a aplica\u00e7\u00e3o deve se comportar. O ciclo 1 - Adicione um teste Normalmente analisamos alguma funcionalidade que desejamos implementar ou validar e escrevemos um teste que ser\u00e1 executado automaticamente relacionado aquela funcionalidade. Ainda que uma fun\u00e7\u00e3o/classe n\u00e3o exista, devemos escrever o comportamento esperado da mesma. 2 - Verifique se algum teste quebrou Neste ponto devemos verificar se os testes passam a falhar(os antigos e o que voc\u00ea acabou de escrever) 3 - Escreva c\u00f3digo Escreva c\u00f3digo necess\u00e1rio para que seu teste seja contemplado, mas evite escrever muito al\u00e9m do que necess\u00e1rio. 4 - Refatore seu c\u00f3digo Com os testes passando, analise se \u00e9 poss\u00edvel alguma refatora\u00e7\u00e3o. 5 - Volte para o passo 1 Ainda n\u00e3o ficou claro o processo? N\u00e3o se preocupe, daqui pra frente iremos ver este ciclo na pr\u00e1tica. \u21a9\ufe0f Voltar","title":"\ud83d\udc10 Desenvolvimento guiado por testes (TDD)"},{"location":"tdd/#desenvolvimento-guiado-por-testes-tdd","text":"","title":"\ud83d\udc10 Desenvolvimento guiado por testes (TDD)"},{"location":"tdd/#testes-automatizados","text":"Talvez tenha chegado aqui sem conhecimento sobre testes automatizados, por isso vamos a uma breve explica\u00e7\u00e3o. \u00c9 muito comum enquanto estamos desenvolvendo, testarmos manualmente as funcionalidades que estamos implementando, mas o que pode ocorrer se eu me esquecer de testar alguma funcionalidade? Por isso escrevemos c\u00f3digo para testar o c\u00f3digo das nossas funcionalidades. Automatizar testes \u00e9 uma maneira de agilizar nosso processo de desenvolvimento, garantindo que novas funcionalidades n\u00e3o impactam sobre as antigas. Um exemplo de teste automatizado. c\u00f3digo def \u00e9_impar ( numero ): 'Retorna True se um n\u00famero \u00e9 verdadeiro, sen\u00e3o False.' return numero % 2 != 0 teste def test_quando_entrada_\u00e9_tr\u00eas_retorna_verdadeiro (): assert \u00e9_impar ( 3 ) is True def test_quando_entrada_\u00e9_dois_retorna_falso (): assert \u00e9_impar ( 2 ) is False \u00c9 importante notar que nos testes eu tento cobrir todas as possibilidades de resultado daquela fun\u00e7\u00e3o, como no exemplo que testo a fun\u00e7\u00e3o para valores pares e \u00edmpares.","title":"Testes automatizados"},{"location":"tdd/#o-que-e-tdd","text":"Desenvolvimento guiado por testes(Test Driven Development) \u00e9 uma t\u00e9cnica de desenvolvimento de software que baseia em um ciclo curto de repeti\u00e7\u00f5es: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Ent\u00e3o, \u00e9 produzido c\u00f3digo que possa ser validado pelo teste para posteriormente o c\u00f3digo ser refatorado para um c\u00f3digo sob padr\u00f5es aceit\u00e1veis. Mas por que TDD? Escrever testes antes do c\u00f3digo ajuda no planejamento da arquitetura da aplica\u00e7\u00e3o, e os testes podem ser um guia de como a aplica\u00e7\u00e3o deve se comportar.","title":"O que \u00e9 TDD?"},{"location":"tdd/#o-ciclo","text":"1 - Adicione um teste Normalmente analisamos alguma funcionalidade que desejamos implementar ou validar e escrevemos um teste que ser\u00e1 executado automaticamente relacionado aquela funcionalidade. Ainda que uma fun\u00e7\u00e3o/classe n\u00e3o exista, devemos escrever o comportamento esperado da mesma. 2 - Verifique se algum teste quebrou Neste ponto devemos verificar se os testes passam a falhar(os antigos e o que voc\u00ea acabou de escrever) 3 - Escreva c\u00f3digo Escreva c\u00f3digo necess\u00e1rio para que seu teste seja contemplado, mas evite escrever muito al\u00e9m do que necess\u00e1rio. 4 - Refatore seu c\u00f3digo Com os testes passando, analise se \u00e9 poss\u00edvel alguma refatora\u00e7\u00e3o. 5 - Volte para o passo 1 Ainda n\u00e3o ficou claro o processo? N\u00e3o se preocupe, daqui pra frente iremos ver este ciclo na pr\u00e1tica. \u21a9\ufe0f Voltar","title":"O ciclo"}]}